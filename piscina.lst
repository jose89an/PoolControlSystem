CCS PCH C Compiler, Version 3.249, 28193               26-feb-11 20:35

               Filename: E:\Jose\Documents\Teleco\2010-2011\SED\Proyecto\Piscina\piscina.lst

               ROM used: 16536 bytes (50%)
                         Largest free fragment is 16228
               RAM used: 83 (5%) at main() level
                         139 (9%) worst case
               Stack:    9 worst case (7 in main + 2 for interrupts)

*
0000:  GOTO   3DFE
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   0A24
0058:  BTFSS  FF2.4
005A:  GOTO   0064
005E:  BTFSC  FF2.1
0060:  GOTO   0AE6
0064:  BTFSS  FF0.3
0066:  GOTO   0070
006A:  BTFSC  FF0.0
006C:  GOTO   0AF0
0070:  MOVFF  0F,00
0074:  MOVFF  10,01
0078:  MOVFF  11,02
007C:  MOVFF  12,03
0080:  MOVFF  13,04
0084:  MOVFF  0D,FE9
0088:  MOVFF  08,FEA
008C:  MOVFF  09,FE1
0090:  MOVFF  0A,FE2
0094:  MOVFF  0B,FD9
0098:  MOVFF  0C,FDA
009C:  MOVFF  14,FF3
00A0:  MOVFF  15,FF4
00A4:  MOVFF  16,FFA
00A8:  MOVF   05,W
00AA:  MOVFF  07,FE0
00AE:  MOVFF  06,FD8
00B2:  RETFIE 0
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva   
00B4:  MOVFF  FF2,0E
00B8:  BCF    FF2.7
00BA:  CLRF   FF7
00BC:  ADDLW  CE
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  BTFSC  0E.7
00CA:  BSF    FF2.7
00CC:  RETURN 0
00CE:  DATA 44,4F
00D0:  DATA 4D,00
00D2:  DATA 00,00
00D4:  DATA 00,00
00D6:  DATA 00,00
00D8:  DATA 4C,55
00DA:  DATA 4E,00
00DC:  DATA 00,00
00DE:  DATA 00,00
00E0:  DATA 00,00
00E2:  DATA 4D,41
00E4:  DATA 52,00
00E6:  DATA 00,00
00E8:  DATA 00,00
00EA:  DATA 00,00
00EC:  DATA 4D,49
00EE:  DATA 45,00
00F0:  DATA 00,00
00F2:  DATA 00,00
00F4:  DATA 00,00
00F6:  DATA 4A,55
00F8:  DATA 45,00
00FA:  DATA 00,00
00FC:  DATA 00,00
00FE:  DATA 00,00
0100:  DATA 56,49
0102:  DATA 45,00
0104:  DATA 00,00
0106:  DATA 00,00
0108:  DATA 00,00
010A:  DATA 53,41
010C:  DATA 42,00
010E:  DATA 00,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  MOVFF  FF2,0E
0118:  BCF    FF2.7
011A:  CLRF   FF7
011C:  ADDLW  2E
011E:  MOVWF  FF6
0120:  MOVLW  01
0122:  ADDWFC FF7,F
0124:  TBLRD*+
0126:  MOVF   FF5,W
0128:  BTFSC  0E.7
012A:  BSF    FF2.7
012C:  RETURN 0
012E:  DATA 2C,0F
0130:  DATA 01,06
0132:  MOVFF  FF2,0E
0136:  BCF    FF2.7
0138:  CLRF   FF7
013A:  ADDLW  4C
013C:  MOVWF  FF6
013E:  MOVLW  01
0140:  ADDWFC FF7,F
0142:  TBLRD*+
0144:  MOVF   FF5,W
0146:  BTFSC  0E.7
0148:  BSF    FF2.7
014A:  RETURN 0
014C:  DATA 01,02
014E:  DATA 03,04
0150:  DATA 05,06
0152:  DATA 07,08
0154:  DATA 09,0A
0156:  DATA 00,0A
0158:  MOVFF  FF2,0E
015C:  BCF    FF2.7
015E:  CLRF   FF7
0160:  ADDLW  72
0162:  MOVWF  FF6
0164:  MOVLW  01
0166:  ADDWFC FF7,F
0168:  TBLRD*+
016A:  MOVF   FF5,W
016C:  BTFSC  0E.7
016E:  BSF    FF2.7
0170:  RETURN 0
0172:  DATA 4D,45
0174:  DATA 4E,55
0176:  DATA 20,44
0178:  DATA 45,4C
017A:  DATA 20,53
017C:  DATA 49,53
017E:  DATA 54,45
0180:  DATA 4D,41
0182:  DATA 00,00
0184:  MOVFF  FF2,0E
0188:  BCF    FF2.7
018A:  CLRF   FF7
018C:  ADDLW  9E
018E:  MOVWF  FF6
0190:  MOVLW  01
0192:  ADDWFC FF7,F
0194:  TBLRD*+
0196:  MOVF   FF5,W
0198:  BTFSC  0E.7
019A:  BSF    FF2.7
019C:  RETURN 0
019E:  DATA 44,65
01A0:  DATA 70,75
01A2:  DATA 72,61
01A4:  DATA 64,6F
01A6:  DATA 72,61
01A8:  DATA 20,20
01AA:  DATA 20,20
01AC:  DATA 20,20
01AE:  DATA 00,00
01B0:  MOVFF  FF2,0E
01B4:  BCF    FF2.7
01B6:  CLRF   FF7
01B8:  ADDLW  CA
01BA:  MOVWF  FF6
01BC:  MOVLW  01
01BE:  ADDWFC FF7,F
01C0:  TBLRD*+
01C2:  MOVF   FF5,W
01C4:  BTFSC  0E.7
01C6:  BSF    FF2.7
01C8:  RETURN 0
01CA:  DATA 54,65
01CC:  DATA 6D,70
01CE:  DATA 65,72
01D0:  DATA 61,74
01D2:  DATA 75,72
01D4:  DATA 61,20
01D6:  DATA 61,67
01D8:  DATA 75,61
01DA:  DATA 00,00
01DC:  MOVFF  FF2,0E
01E0:  BCF    FF2.7
01E2:  CLRF   FF7
01E4:  ADDLW  F6
01E6:  MOVWF  FF6
01E8:  MOVLW  01
01EA:  ADDWFC FF7,F
01EC:  TBLRD*+
01EE:  MOVF   FF5,W
01F0:  BTFSC  0E.7
01F2:  BSF    FF2.7
01F4:  RETURN 0
01F6:  DATA 4E,69
01F8:  DATA 76,65
01FA:  DATA 6C,20
01FC:  DATA 63,6C
01FE:  DATA 6F,72
0200:  DATA 6F,20
0202:  DATA 20,20
0204:  DATA 20,20
0206:  DATA 00,00
0208:  MOVFF  FF2,0E
020C:  BCF    FF2.7
020E:  CLRF   FF7
0210:  ADDLW  22
0212:  MOVWF  FF6
0214:  MOVLW  02
0216:  ADDWFC FF7,F
0218:  TBLRD*+
021A:  MOVF   FF5,W
021C:  BTFSC  0E.7
021E:  BSF    FF2.7
0220:  RETURN 0
0222:  DATA 4E,69
0224:  DATA 76,65
0226:  DATA 6C,20
0228:  DATA 74,75
022A:  DATA 72,62
022C:  DATA 69,64
022E:  DATA 65,7A
0230:  DATA 20,20
0232:  DATA 00,00
0234:  MOVFF  FF2,0E
0238:  BCF    FF2.7
023A:  CLRF   FF7
023C:  ADDLW  4E
023E:  MOVWF  FF6
0240:  MOVLW  02
0242:  ADDWFC FF7,F
0244:  TBLRD*+
0246:  MOVF   FF5,W
0248:  BTFSC  0E.7
024A:  BSF    FF2.7
024C:  RETURN 0
024E:  DATA 48,6F
0250:  DATA 72,61
0252:  DATA 20,69
0254:  DATA 6E,2E
0256:  DATA 3A,20
0258:  DATA 25,75
025A:  DATA 3A,25
025C:  DATA 75,00
025E:  MOVFF  FF2,0E
0262:  BCF    FF2.7
0264:  CLRF   FF7
0266:  ADDLW  78
0268:  MOVWF  FF6
026A:  MOVLW  02
026C:  ADDWFC FF7,F
026E:  TBLRD*+
0270:  MOVF   FF5,W
0272:  BTFSC  0E.7
0274:  BSF    FF2.7
0276:  RETURN 0
0278:  DATA 4D,6F
027A:  DATA 64,69
027C:  DATA 66,69
027E:  DATA 63,61
0280:  DATA 72,3F
0282:  DATA 00,00
0284:  MOVFF  FF2,0E
0288:  BCF    FF2.7
028A:  CLRF   FF7
028C:  ADDLW  9E
028E:  MOVWF  FF6
0290:  MOVLW  02
0292:  ADDWFC FF7,F
0294:  TBLRD*+
0296:  MOVF   FF5,W
0298:  BTFSC  0E.7
029A:  BSF    FF2.7
029C:  RETURN 0
029E:  DATA 48,6F
02A0:  DATA 72,61
02A2:  DATA 20,66
02A4:  DATA 69,6E
02A6:  DATA 3A,20
02A8:  DATA 25,75
02AA:  DATA 3A,25
02AC:  DATA 75,00
02AE:  MOVFF  FF2,0E
02B2:  BCF    FF2.7
02B4:  CLRF   FF7
02B6:  ADDLW  C8
02B8:  MOVWF  FF6
02BA:  MOVLW  02
02BC:  ADDWFC FF7,F
02BE:  TBLRD*+
02C0:  MOVF   FF5,W
02C2:  BTFSC  0E.7
02C4:  BSF    FF2.7
02C6:  RETURN 0
02C8:  DATA 4E,75
02CA:  DATA 65,76
02CC:  DATA 61,20
02CE:  DATA 68,6F
02D0:  DATA 72,61
02D2:  DATA 20,69
02D4:  DATA 6E,69
02D6:  DATA 63,2E
02D8:  DATA 00,00
02DA:  MOVFF  FF2,0E
02DE:  BCF    FF2.7
02E0:  CLRF   FF7
02E2:  ADDLW  F4
02E4:  MOVWF  FF6
02E6:  MOVLW  02
02E8:  ADDWFC FF7,F
02EA:  TBLRD*+
02EC:  MOVF   FF5,W
02EE:  BTFSC  0E.7
02F0:  BSF    FF2.7
02F2:  RETURN 0
02F4:  DATA 4E,75
02F6:  DATA 65,76
02F8:  DATA 61,20
02FA:  DATA 68,6F
02FC:  DATA 72,61
02FE:  DATA 20,66
0300:  DATA 69,6E
0302:  DATA 00,00
0304:  MOVFF  FF2,0E
0308:  BCF    FF2.7
030A:  CLRF   FF7
030C:  ADDLW  1E
030E:  MOVWF  FF6
0310:  MOVLW  03
0312:  ADDWFC FF7,F
0314:  TBLRD*+
0316:  MOVF   FF5,W
0318:  BTFSC  0E.7
031A:  BSF    FF2.7
031C:  RETURN 0
031E:  DATA 46,6F
0320:  DATA 72,6D
0322:  DATA 61,74
0324:  DATA 6F,3A
0326:  DATA 20,58
0328:  DATA 58,3A
032A:  DATA 58,58
032C:  DATA 00,00
032E:  MOVFF  FF2,0E
0332:  BCF    FF2.7
0334:  CLRF   FF7
0336:  ADDLW  48
0338:  MOVWF  FF6
033A:  MOVLW  03
033C:  ADDWFC FF7,F
033E:  TBLRD*+
0340:  MOVF   FF5,W
0342:  BTFSC  0E.7
0344:  BSF    FF2.7
0346:  RETURN 0
0348:  DATA 54,65
034A:  DATA 6D,70
034C:  DATA 2E,20
034E:  DATA 64,65
0350:  DATA 73,2E
0352:  DATA 3A,20
0354:  DATA 25,32
0356:  DATA 2E,31
0358:  DATA 66,00
035A:  MOVFF  FF2,0E
035E:  BCF    FF2.7
0360:  CLRF   FF7
0362:  ADDLW  74
0364:  MOVWF  FF6
0366:  MOVLW  03
0368:  ADDWFC FF7,F
036A:  TBLRD*+
036C:  MOVF   FF5,W
036E:  BTFSC  0E.7
0370:  BSF    FF2.7
0372:  RETURN 0
0374:  DATA 49,6E
0376:  DATA 74,72
0378:  DATA 6F,64
037A:  DATA 75,7A
037C:  DATA 63,61
037E:  DATA 20,74
0380:  DATA 65,6D
0382:  DATA 70,2E
0384:  DATA 00,00
0386:  MOVFF  FF2,0E
038A:  BCF    FF2.7
038C:  CLRF   FF7
038E:  ADDLW  A0
0390:  MOVWF  FF6
0392:  MOVLW  03
0394:  ADDWFC FF7,F
0396:  TBLRD*+
0398:  MOVF   FF5,W
039A:  BTFSC  0E.7
039C:  BSF    FF2.7
039E:  RETURN 0
03A0:  DATA 46,6F
03A2:  DATA 72,6D
03A4:  DATA 61,74
03A6:  DATA 6F,3A
03A8:  DATA 20,58
03AA:  DATA 58,2E
03AC:  DATA 58,00
03AE:  MOVFF  FF2,0E
03B2:  BCF    FF2.7
03B4:  CLRF   FF7
03B6:  ADDLW  C8
03B8:  MOVWF  FF6
03BA:  MOVLW  03
03BC:  ADDWFC FF7,F
03BE:  TBLRD*+
03C0:  MOVF   FF5,W
03C2:  BTFSC  0E.7
03C4:  BSF    FF2.7
03C6:  RETURN 0
03C8:  DATA 43,6C
03CA:  DATA 6F,72
03CC:  DATA 6F,2E
03CE:  DATA 20,64
03D0:  DATA 65,73
03D2:  DATA 2E,3A
03D4:  DATA 20,25
03D6:  DATA 31,2E
03D8:  DATA 31,66
03DA:  DATA 00,00
03DC:  MOVFF  FF2,0E
03E0:  BCF    FF2.7
03E2:  CLRF   FF7
03E4:  ADDLW  F6
03E6:  MOVWF  FF6
03E8:  MOVLW  03
03EA:  ADDWFC FF7,F
03EC:  TBLRD*+
03EE:  MOVF   FF5,W
03F0:  BTFSC  0E.7
03F2:  BSF    FF2.7
03F4:  RETURN 0
03F6:  DATA 4E,75
03F8:  DATA 65,76
03FA:  DATA 6F,20
03FC:  DATA 6E,76
03FE:  DATA 2E,20
0400:  DATA 63,6C
0402:  DATA 6F,72
0404:  DATA 6F,00
0406:  MOVFF  FF2,0E
040A:  BCF    FF2.7
040C:  CLRF   FF7
040E:  ADDLW  20
0410:  MOVWF  FF6
0412:  MOVLW  04
0414:  ADDWFC FF7,F
0416:  TBLRD*+
0418:  MOVF   FF5,W
041A:  BTFSC  0E.7
041C:  BSF    FF2.7
041E:  RETURN 0
0420:  DATA 46,6F
0422:  DATA 72,6D
0424:  DATA 61,74
0426:  DATA 6F,3A
0428:  DATA 20,58
042A:  DATA 2E,58
042C:  DATA 00,00
042E:  MOVFF  FF2,0E
0432:  BCF    FF2.7
0434:  CLRF   FF7
0436:  ADDLW  48
0438:  MOVWF  FF6
043A:  MOVLW  04
043C:  ADDWFC FF7,F
043E:  TBLRD*+
0440:  MOVF   FF5,W
0442:  BTFSC  0E.7
0444:  BSF    FF2.7
0446:  RETURN 0
0448:  DATA 54,75
044A:  DATA 72,62
044C:  DATA 69,2E
044E:  DATA 20,64
0450:  DATA 65,73
0452:  DATA 2E,3A
0454:  DATA 20,25
0456:  DATA 31,2E
0458:  DATA 31,66
045A:  DATA 00,00
045C:  MOVFF  FF2,0E
0460:  BCF    FF2.7
0462:  CLRF   FF7
0464:  ADDLW  76
0466:  MOVWF  FF6
0468:  MOVLW  04
046A:  ADDWFC FF7,F
046C:  TBLRD*+
046E:  MOVF   FF5,W
0470:  BTFSC  0E.7
0472:  BSF    FF2.7
0474:  RETURN 0
0476:  DATA 4E,75
0478:  DATA 65,76
047A:  DATA 6F,20
047C:  DATA 6E,76
047E:  DATA 2E,20
0480:  DATA 74,75
0482:  DATA 72,62
0484:  DATA 2E,00
0486:  MOVFF  FF2,0E
048A:  BCF    FF2.7
048C:  CLRF   FF7
048E:  ADDLW  A0
0490:  MOVWF  FF6
0492:  MOVLW  04
0494:  ADDWFC FF7,F
0496:  TBLRD*+
0498:  MOVF   FF5,W
049A:  BTFSC  0E.7
049C:  BSF    FF2.7
049E:  RETURN 0
04A0:  DATA 43,4C
04A2:  DATA 4F,52
04A4:  DATA 4F,3A
04A6:  DATA 20,25
04A8:  DATA 33,2E
04AA:  DATA 32,66
04AC:  DATA 20,0A
04AE:  DATA 54,55
04B0:  DATA 52,42
04B2:  DATA 49,44
04B4:  DATA 45,5A
04B6:  DATA 3A,20
04B8:  DATA 25,33
04BA:  DATA 2E,32
04BC:  DATA 66,20
04BE:  DATA 00,00
04C0:  MOVFF  FF2,0E
04C4:  BCF    FF2.7
04C6:  CLRF   FF7
04C8:  ADDLW  DA
04CA:  MOVWF  FF6
04CC:  MOVLW  04
04CE:  ADDWFC FF7,F
04D0:  TBLRD*+
04D2:  MOVF   FF5,W
04D4:  BTFSC  0E.7
04D6:  BSF    FF2.7
04D8:  RETURN 0
04DA:  DATA 54,45
04DC:  DATA 4D,50
04DE:  DATA 3A,20
04E0:  DATA 25,33
04E2:  DATA 2E,31
04E4:  DATA 66,20
04E6:  DATA 25,63
04E8:  DATA 43,20
04EA:  DATA 0A,48
04EC:  DATA 6F,72
04EE:  DATA 61,3A
04F0:  DATA 20,25
04F2:  DATA 75,3A
04F4:  DATA 25,32
04F6:  DATA 75,3A
04F8:  DATA 25,32
04FA:  DATA 75,00
04FC:  MOVFF  FF2,0E
0500:  BCF    FF2.7
0502:  CLRF   FF7
0504:  ADDLW  16
0506:  MOVWF  FF6
0508:  MOVLW  05
050A:  ADDWFC FF7,F
050C:  TBLRD*+
050E:  MOVF   FF5,W
0510:  BTFSC  0E.7
0512:  BSF    FF2.7
0514:  RETURN 0
0516:  DATA 4C,65
0518:  DATA 63,74
051A:  DATA 75,72
051C:  DATA 61,20
051E:  DATA 64,65
0520:  DATA 20,45
0522:  DATA 65,70
0524:  DATA 72,6F
0526:  DATA 6D,20
0528:  DATA 68,65
052A:  DATA 63,68
052C:  DATA 61,20
052E:  DATA 61,20
0530:  DATA 6C,61
0532:  DATA 73,20
0534:  DATA 25,75
0536:  DATA 3A,25
0538:  DATA 32,75
053A:  DATA 3A,25
053C:  DATA 32,75
053E:  DATA 0A,0D
0540:  DATA 0A,0D
0542:  DATA 00,00
0544:  MOVFF  FF2,0E
0548:  BCF    FF2.7
054A:  CLRF   FF7
054C:  ADDLW  5E
054E:  MOVWF  FF6
0550:  MOVLW  05
0552:  ADDWFC FF7,F
0554:  TBLRD*+
0556:  MOVF   FF5,W
0558:  BTFSC  0E.7
055A:  BSF    FF2.7
055C:  RETURN 0
055E:  DATA 48,6F
0560:  DATA 72,61
0562:  DATA 20,69
0564:  DATA 6E,69
0566:  DATA 63,69
0568:  DATA 6F,20
056A:  DATA 63,69
056C:  DATA 63,6C
056E:  DATA 6F,20
0570:  DATA 64,65
0572:  DATA 70,75
0574:  DATA 72,61
0576:  DATA 64,6F
0578:  DATA 72,61
057A:  DATA 3A,20
057C:  DATA 25,75
057E:  DATA 3A,25
0580:  DATA 75,0A
0582:  DATA 0D,00
0584:  MOVFF  FF2,0E
0588:  BCF    FF2.7
058A:  CLRF   FF7
058C:  ADDLW  9E
058E:  MOVWF  FF6
0590:  MOVLW  05
0592:  ADDWFC FF7,F
0594:  TBLRD*+
0596:  MOVF   FF5,W
0598:  BTFSC  0E.7
059A:  BSF    FF2.7
059C:  RETURN 0
059E:  DATA 48,6F
05A0:  DATA 72,61
05A2:  DATA 20,66
05A4:  DATA 69,6E
05A6:  DATA 20,63
05A8:  DATA 69,63
05AA:  DATA 6C,6F
05AC:  DATA 20,64
05AE:  DATA 65,70
05B0:  DATA 75,72
05B2:  DATA 61,64
05B4:  DATA 6F,72
05B6:  DATA 61,3A
05B8:  DATA 20,25
05BA:  DATA 75,3A
05BC:  DATA 25,75
05BE:  DATA 0A,0D
05C0:  DATA 00,00
05C2:  MOVFF  FF2,0E
05C6:  BCF    FF2.7
05C8:  CLRF   FF7
05CA:  ADDLW  DC
05CC:  MOVWF  FF6
05CE:  MOVLW  05
05D0:  ADDWFC FF7,F
05D2:  TBLRD*+
05D4:  MOVF   FF5,W
05D6:  BTFSC  0E.7
05D8:  BSF    FF2.7
05DA:  RETURN 0
05DC:  DATA 54,65
05DE:  DATA 6D,70
05E0:  DATA 65,72
05E2:  DATA 61,74
05E4:  DATA 75,72
05E6:  DATA 61,20
05E8:  DATA 6D,69
05EA:  DATA 6E,69
05EC:  DATA 6D,61
05EE:  DATA 20,64
05F0:  DATA 65,73
05F2:  DATA 65,61
05F4:  DATA 64,61
05F6:  DATA 3A,20
05F8:  DATA 25,32
05FA:  DATA 2E,31
05FC:  DATA 66,0A
05FE:  DATA 0D,00
0600:  MOVFF  FF2,0E
0604:  BCF    FF2.7
0606:  CLRF   FF7
0608:  ADDLW  1A
060A:  MOVWF  FF6
060C:  MOVLW  06
060E:  ADDWFC FF7,F
0610:  TBLRD*+
0612:  MOVF   FF5,W
0614:  BTFSC  0E.7
0616:  BSF    FF2.7
0618:  RETURN 0
061A:  DATA 4E,69
061C:  DATA 76,65
061E:  DATA 6C,20
0620:  DATA 6D,69
0622:  DATA 6E,69
0624:  DATA 6D,6F
0626:  DATA 20,64
0628:  DATA 65,20
062A:  DATA 63,6C
062C:  DATA 6F,72
062E:  DATA 6F,20
0630:  DATA 65,78
0632:  DATA 69,67
0634:  DATA 69,64
0636:  DATA 6F,3A
0638:  DATA 20,25
063A:  DATA 31,2E
063C:  DATA 31,66
063E:  DATA 0A,0D
0640:  DATA 00,00
0642:  MOVFF  FF2,0E
0646:  BCF    FF2.7
0648:  CLRF   FF7
064A:  ADDLW  5C
064C:  MOVWF  FF6
064E:  MOVLW  06
0650:  ADDWFC FF7,F
0652:  TBLRD*+
0654:  MOVF   FF5,W
0656:  BTFSC  0E.7
0658:  BSF    FF2.7
065A:  RETURN 0
065C:  DATA 4E,69
065E:  DATA 76,65
0660:  DATA 6C,20
0662:  DATA 6D,61
0664:  DATA 78,69
0666:  DATA 6D,6F
0668:  DATA 20,64
066A:  DATA 65,20
066C:  DATA 74,75
066E:  DATA 72,62
0670:  DATA 69,64
0672:  DATA 65,7A
0674:  DATA 20,70
0676:  DATA 65,72
0678:  DATA 6D,69
067A:  DATA 74,69
067C:  DATA 64,61
067E:  DATA 3A,20
0680:  DATA 25,31
0682:  DATA 2E,31
0684:  DATA 66,0A
0686:  DATA 0D,00
0688:  MOVFF  FF2,0E
068C:  BCF    FF2.7
068E:  CLRF   FF7
0690:  ADDLW  A2
0692:  MOVWF  FF6
0694:  MOVLW  06
0696:  ADDWFC FF7,F
0698:  TBLRD*+
069A:  MOVF   FF5,W
069C:  BTFSC  0E.7
069E:  BSF    FF2.7
06A0:  RETURN 0
06A2:  DATA 2D,2D
06A4:  DATA 2D,2D
06A6:  DATA 2D,2D
06A8:  DATA 2D,2D
06AA:  DATA 2D,2D
06AC:  DATA 2D,2D
06AE:  DATA 2D,2D
06B0:  DATA 2D,2D
06B2:  DATA 2D,2D
06B4:  DATA 2D,2D
06B6:  DATA 2D,2D
06B8:  DATA 2D,2D
06BA:  DATA 2D,2D
06BC:  DATA 2D,2D
06BE:  DATA 2D,2D
06C0:  DATA 2D,2D
06C2:  DATA 2D,2D
06C4:  DATA 2D,2D
06C6:  DATA 0A,0D
06C8:  DATA 00,00
06CA:  MOVFF  FF2,0E
06CE:  BCF    FF2.7
06D0:  CLRF   FF7
06D2:  ADDLW  E4
06D4:  MOVWF  FF6
06D6:  MOVLW  06
06D8:  ADDWFC FF7,F
06DA:  TBLRD*+
06DC:  MOVF   FF5,W
06DE:  BTFSC  0E.7
06E0:  BSF    FF2.7
06E2:  RETURN 0
06E4:  DATA 42,69
06E6:  DATA 65,6E
06E8:  DATA 76,65
06EA:  DATA 6E,69
06EC:  DATA 64,6F
06EE:  DATA 20,61
06F0:  DATA 6C,20
06F2:  DATA 73,69
06F4:  DATA 73,74
06F6:  DATA 65,6D
06F8:  DATA 61,20
06FA:  DATA 64,65
06FC:  DATA 20,63
06FE:  DATA 6F,6E
0700:  DATA 74,72
0702:  DATA 6F,6C
0704:  DATA 20,64
0706:  DATA 65,20
0708:  DATA 6C,61
070A:  DATA 20,70
070C:  DATA 69,73
070E:  DATA 63,69
0710:  DATA 6E,61
0712:  DATA 0A,0D
0714:  DATA 0A,0D
0716:  DATA 0A,0D
0718:  DATA 00,00
071A:  MOVFF  FF2,0E
071E:  BCF    FF2.7
0720:  CLRF   FF7
0722:  ADDLW  34
0724:  MOVWF  FF6
0726:  MOVLW  07
0728:  ADDWFC FF7,F
072A:  TBLRD*+
072C:  MOVF   FF5,W
072E:  BTFSC  0E.7
0730:  BSF    FF2.7
0732:  RETURN 0
0734:  DATA 48,6F
0736:  DATA 72,61
0738:  DATA 20,61
073A:  DATA 63,74
073C:  DATA 75,61
073E:  DATA 6C,3F
0740:  DATA 00,00
0742:  MOVFF  7C,83
0746:  MOVF   x80,W
0748:  XORWF  x83,F
074A:  BTFSS  x83.7
074C:  BRA    0758
074E:  BCF    FD8.2
0750:  BCF    FD8.0
0752:  BTFSC  7C.7
0754:  BSF    FD8.0
0756:  BRA    07B6
0758:  MOVFF  7C,83
075C:  MOVFF  7F,84
0760:  MOVF   7B,W
0762:  SUBWF  x84,F
0764:  BZ    0772
0766:  BTFSS  x83.7
0768:  BRA    07B6
076A:  MOVF   FD8,W
076C:  XORLW  01
076E:  MOVWF  FD8
0770:  BRA    07B6
0772:  MOVFF  80,84
0776:  MOVF   7C,W
0778:  SUBWF  x84,F
077A:  BZ    0788
077C:  BTFSS  x83.7
077E:  BRA    07B6
0780:  MOVF   FD8,W
0782:  XORLW  01
0784:  MOVWF  FD8
0786:  BRA    07B6
0788:  MOVFF  81,84
078C:  MOVF   7D,W
078E:  SUBWF  x84,F
0790:  BZ    079E
0792:  BTFSS  x83.7
0794:  BRA    07B6
0796:  MOVF   FD8,W
0798:  XORLW  01
079A:  MOVWF  FD8
079C:  BRA    07B6
079E:  MOVFF  82,84
07A2:  MOVF   7E,W
07A4:  SUBWF  x84,F
07A6:  BZ    07B4
07A8:  BTFSS  x83.7
07AA:  BRA    07B6
07AC:  MOVF   FD8,W
07AE:  XORLW  01
07B0:  MOVWF  FD8
07B2:  BRA    07B6
07B4:  BCF    FD8.0
07B6:  RETLW  00
07B8:  MOVLW  80
07BA:  BTFSC  FD8.1
07BC:  XORWF  x80,F
07BE:  CLRF   x85
07C0:  CLRF   x86
07C2:  MOVFF  7C,84
07C6:  MOVF   x80,W
07C8:  XORWF  x84,F
07CA:  MOVF   7B,W
07CC:  BTFSC  FD8.2
07CE:  BRA    0988
07D0:  MOVWF  x83
07D2:  MOVWF  00
07D4:  MOVF   7F,W
07D6:  BTFSC  FD8.2
07D8:  BRA    099A
07DA:  SUBWF  x83,F
07DC:  BTFSC  FD8.2
07DE:  BRA    08E2
07E0:  BNC   085C
07E2:  MOVFF  80,89
07E6:  BSF    x89.7
07E8:  MOVFF  81,88
07EC:  MOVFF  82,87
07F0:  CLRF   x86
07F2:  BCF    FD8.0
07F4:  RRCF   x89,F
07F6:  RRCF   x88,F
07F8:  RRCF   x87,F
07FA:  RRCF   x86,F
07FC:  DECFSZ x83,F
07FE:  BRA    07F0
0800:  BTFSS  x84.7
0802:  BRA    080A
0804:  BSF    x85.0
0806:  BRA    09C2
0808:  BCF    x85.0
080A:  BCF    x83.0
080C:  BSF    x85.4
080E:  CLRF   FEA
0810:  MOVLW  7E
0812:  MOVWF  FE9
0814:  BRA    09E8
0816:  BCF    x85.4
0818:  BTFSC  x84.7
081A:  BRA    0830
081C:  BTFSS  x83.0
081E:  BRA    0846
0820:  RRCF   x89,F
0822:  RRCF   x88,F
0824:  RRCF   x87,F
0826:  RRCF   x86,F
0828:  INCF   00,F
082A:  BTFSC  FD8.2
082C:  BRA    09B8
082E:  BRA    0846
0830:  BTFSC  x89.7
0832:  BRA    084C
0834:  BCF    FD8.0
0836:  RLCF   x86,F
0838:  RLCF   x87,F
083A:  RLCF   x88,F
083C:  RLCF   x89,F
083E:  DECF   00,F
0840:  BTFSC  FD8.2
0842:  BRA    09B8
0844:  BRA    0830
0846:  BSF    x85.6
0848:  BRA    0920
084A:  BCF    x85.6
084C:  MOVFF  7C,84
0850:  BTFSS  7C.7
0852:  BRA    0858
0854:  BSF    x89.7
0856:  BRA    09AA
0858:  BCF    x89.7
085A:  BRA    09AA
085C:  MOVFF  7F,83
0860:  MOVFF  7F,00
0864:  MOVF   7B,W
0866:  SUBWF  x83,F
0868:  MOVFF  7C,89
086C:  BSF    x89.7
086E:  MOVFF  7D,88
0872:  MOVFF  7E,87
0876:  CLRF   x86
0878:  BCF    FD8.0
087A:  RRCF   x89,F
087C:  RRCF   x88,F
087E:  RRCF   x87,F
0880:  RRCF   x86,F
0882:  DECFSZ x83,F
0884:  BRA    0876
0886:  BTFSS  x84.7
0888:  BRA    0890
088A:  BSF    x85.1
088C:  BRA    09C2
088E:  BCF    x85.1
0890:  BCF    x83.0
0892:  BSF    x85.5
0894:  CLRF   FEA
0896:  MOVLW  82
0898:  MOVWF  FE9
089A:  BRA    09E8
089C:  BCF    x85.5
089E:  BTFSC  x84.7
08A0:  BRA    08B6
08A2:  BTFSS  x83.0
08A4:  BRA    08CC
08A6:  RRCF   x89,F
08A8:  RRCF   x88,F
08AA:  RRCF   x87,F
08AC:  RRCF   x86,F
08AE:  INCF   00,F
08B0:  BTFSC  FD8.2
08B2:  BRA    09B8
08B4:  BRA    08CC
08B6:  BTFSC  x89.7
08B8:  BRA    08D2
08BA:  BCF    FD8.0
08BC:  RLCF   x86,F
08BE:  RLCF   x87,F
08C0:  RLCF   x88,F
08C2:  RLCF   x89,F
08C4:  DECF   00,F
08C6:  BTFSC  FD8.2
08C8:  BRA    09B8
08CA:  BRA    08B6
08CC:  BSF    x85.7
08CE:  BRA    0920
08D0:  BCF    x85.7
08D2:  MOVFF  80,84
08D6:  BTFSS  x80.7
08D8:  BRA    08DE
08DA:  BSF    x89.7
08DC:  BRA    09AA
08DE:  BCF    x89.7
08E0:  BRA    09AA
08E2:  MOVFF  80,89
08E6:  BSF    x89.7
08E8:  MOVFF  81,88
08EC:  MOVFF  82,87
08F0:  BTFSS  x84.7
08F2:  BRA    08FC
08F4:  BCF    x89.7
08F6:  BSF    x85.2
08F8:  BRA    09C2
08FA:  BCF    x85.2
08FC:  CLRF   x86
08FE:  BCF    x83.0
0900:  CLRF   FEA
0902:  MOVLW  7E
0904:  MOVWF  FE9
0906:  BRA    09E8
0908:  BTFSC  x84.7
090A:  BRA    0944
090C:  MOVFF  7C,84
0910:  BTFSS  x83.0
0912:  BRA    0920
0914:  RRCF   x89,F
0916:  RRCF   x88,F
0918:  RRCF   x87,F
091A:  RRCF   x86,F
091C:  INCF   00,F
091E:  BZ    09B8
0920:  BTFSS  x86.7
0922:  BRA    093A
0924:  INCF   x87,F
0926:  BNZ   093A
0928:  INCF   x88,F
092A:  BNZ   093A
092C:  INCF   x89,F
092E:  BNZ   093A
0930:  RRCF   x89,F
0932:  RRCF   x88,F
0934:  RRCF   x87,F
0936:  INCF   00,F
0938:  BZ    09B8
093A:  BTFSC  x85.6
093C:  BRA    084A
093E:  BTFSC  x85.7
0940:  BRA    08D0
0942:  BRA    097C
0944:  MOVLW  80
0946:  XORWF  x89,F
0948:  BTFSS  x89.7
094A:  BRA    0954
094C:  BRA    09C2
094E:  MOVFF  80,84
0952:  BRA    0968
0954:  MOVFF  7C,84
0958:  MOVF   x89,F
095A:  BNZ   0968
095C:  MOVF   x88,F
095E:  BNZ   0968
0960:  MOVF   x87,F
0962:  BNZ   0968
0964:  CLRF   00
0966:  BRA    09AA
0968:  BTFSC  x89.7
096A:  BRA    097C
096C:  BCF    FD8.0
096E:  RLCF   x86,F
0970:  RLCF   x87,F
0972:  RLCF   x88,F
0974:  RLCF   x89,F
0976:  DECFSZ 00,F
0978:  BRA    0968
097A:  BRA    09B8
097C:  BTFSS  x84.7
097E:  BRA    0984
0980:  BSF    x89.7
0982:  BRA    09AA
0984:  BCF    x89.7
0986:  BRA    09AA
0988:  MOVFF  7F,00
098C:  MOVFF  80,89
0990:  MOVFF  81,88
0994:  MOVFF  82,87
0998:  BRA    09AA
099A:  MOVFF  7B,00
099E:  MOVFF  7C,89
09A2:  MOVFF  7D,88
09A6:  MOVFF  7E,87
09AA:  MOVFF  89,01
09AE:  MOVFF  88,02
09B2:  MOVFF  87,03
09B6:  BRA    0A20
09B8:  CLRF   00
09BA:  CLRF   01
09BC:  CLRF   02
09BE:  CLRF   03
09C0:  BRA    0A20
09C2:  CLRF   x86
09C4:  COMF   x87,F
09C6:  COMF   x88,F
09C8:  COMF   x89,F
09CA:  COMF   x86,F
09CC:  INCF   x86,F
09CE:  BNZ   09DA
09D0:  INCF   x87,F
09D2:  BNZ   09DA
09D4:  INCF   x88,F
09D6:  BNZ   09DA
09D8:  INCF   x89,F
09DA:  BTFSC  x85.0
09DC:  BRA    0808
09DE:  BTFSC  x85.1
09E0:  BRA    088E
09E2:  BTFSC  x85.2
09E4:  BRA    08FA
09E6:  BRA    094E
09E8:  MOVF   FEF,W
09EA:  ADDWF  x87,F
09EC:  BNC   09F8
09EE:  INCF   x88,F
09F0:  BNZ   09F8
09F2:  INCF   x89,F
09F4:  BTFSC  FD8.2
09F6:  BSF    x83.0
09F8:  MOVF   FED,F
09FA:  MOVF   FEF,W
09FC:  ADDWF  x88,F
09FE:  BNC   0A06
0A00:  INCF   x89,F
0A02:  BTFSC  FD8.2
0A04:  BSF    x83.0
0A06:  MOVF   FED,F
0A08:  MOVF   FEF,W
0A0A:  BTFSC  FEF.7
0A0C:  BRA    0A10
0A0E:  XORLW  80
0A10:  ADDWF  x89,F
0A12:  BTFSC  FD8.0
0A14:  BSF    x83.0
0A16:  BTFSC  x85.4
0A18:  BRA    0816
0A1A:  BTFSC  x85.5
0A1C:  BRA    089C
0A1E:  BRA    0908
0A20:  NOP   
0A22:  RETLW  00
*
13D6:  MOVF   64,W
13D8:  CLRF   01
13DA:  SUBWF  63,W
13DC:  BC    13E4
13DE:  MOVFF  63,00
13E2:  BRA    13FC
13E4:  CLRF   00
13E6:  MOVLW  08
13E8:  MOVWF  65
13EA:  RLCF   63,F
13EC:  RLCF   00,F
13EE:  MOVF   64,W
13F0:  SUBWF  00,W
13F2:  BTFSC  FD8.0
13F4:  MOVWF  00
13F6:  RLCF   01,F
13F8:  DECFSZ 65,F
13FA:  BRA    13EA
13FC:  RETLW  00
13FE:  MOVF   01,W
1400:  MOVFF  61,63
1404:  MOVLW  64
1406:  MOVWF  64
1408:  RCALL  13D6
140A:  MOVFF  00,61
140E:  MOVF   01,W
1410:  MOVLW  30
1412:  BNZ   1422
1414:  BTFSS  62.1
1416:  BRA    1430
1418:  BTFSC  62.3
141A:  BRA    1430
141C:  BTFSC  62.4
141E:  MOVLW  20
1420:  BRA    1428
1422:  BCF    62.3
1424:  BCF    62.4
1426:  BSF    62.0
1428:  ADDWF  01,F
142A:  MOVFF  01,6E
142E:  RCALL  12E8
1430:  MOVFF  61,63
1434:  MOVLW  0A
1436:  MOVWF  64
1438:  RCALL  13D6
143A:  MOVFF  00,61
143E:  MOVF   01,W
1440:  MOVLW  30
1442:  BNZ   1450
1444:  BTFSC  62.3
1446:  BRA    1458
1448:  BTFSS  62.0
144A:  BRA    1458
144C:  BTFSC  62.4
144E:  MOVLW  20
1450:  ADDWF  01,F
1452:  MOVFF  01,6E
1456:  RCALL  12E8
1458:  MOVLW  30
145A:  ADDWF  61,F
145C:  MOVFF  61,6E
1460:  RCALL  12E8
1462:  RETLW  00
*
167C:  MOVLW  8E
167E:  MOVWF  00
1680:  MOVFF  69,01
1684:  MOVFF  68,02
1688:  CLRF   03
168A:  BTFSS  69.7
168C:  BRA    1698
168E:  COMF   01,F
1690:  COMF   02,F
1692:  INCF   02,F
1694:  BNZ   1698
1696:  INCF   01,F
1698:  MOVF   01,F
169A:  BNZ   16AE
169C:  MOVFF  02,01
16A0:  CLRF   02
16A2:  MOVLW  08
16A4:  SUBWF  00,F
16A6:  MOVF   01,F
16A8:  BNZ   16AE
16AA:  CLRF   00
16AC:  BRA    16C2
16AE:  BCF    FD8.0
16B0:  BTFSC  01.7
16B2:  BRA    16BC
16B4:  RLCF   02,F
16B6:  RLCF   01,F
16B8:  DECF   00,F
16BA:  BRA    16AE
16BC:  BTFSC  69.7
16BE:  BRA    16C2
16C0:  BCF    01.7
16C2:  NOP   
16C4:  GOTO   186C (RETURN)
16C8:  MOVF   6C,W
16CA:  BTFSC  FD8.2
16CC:  BRA    1818
16CE:  MOVWF  78
16D0:  MOVF   70,W
16D2:  BTFSC  FD8.2
16D4:  BRA    1818
16D6:  SUBWF  78,F
16D8:  BNC   16E4
16DA:  MOVLW  7F
16DC:  ADDWF  78,F
16DE:  BTFSC  FD8.0
16E0:  BRA    1818
16E2:  BRA    16F0
16E4:  MOVLW  81
16E6:  SUBWF  78,F
16E8:  BTFSS  FD8.0
16EA:  BRA    1818
16EC:  BTFSC  FD8.2
16EE:  BRA    1818
16F0:  MOVFF  78,00
16F4:  CLRF   01
16F6:  CLRF   02
16F8:  CLRF   03
16FA:  CLRF   77
16FC:  MOVFF  6D,76
1700:  BSF    76.7
1702:  MOVFF  6E,75
1706:  MOVFF  6F,74
170A:  MOVLW  19
170C:  MOVWF  78
170E:  MOVF   73,W
1710:  SUBWF  74,F
1712:  BC    172E
1714:  MOVLW  01
1716:  SUBWF  75,F
1718:  BC    172E
171A:  SUBWF  76,F
171C:  BC    172E
171E:  SUBWF  77,F
1720:  BC    172E
1722:  INCF   77,F
1724:  INCF   76,F
1726:  INCF   75,F
1728:  MOVF   73,W
172A:  ADDWF  74,F
172C:  BRA    177E
172E:  MOVF   72,W
1730:  SUBWF  75,F
1732:  BC    1758
1734:  MOVLW  01
1736:  SUBWF  76,F
1738:  BC    1758
173A:  SUBWF  77,F
173C:  BC    1758
173E:  INCF   77,F
1740:  INCF   76,F
1742:  MOVF   72,W
1744:  ADDWF  75,F
1746:  MOVF   73,W
1748:  ADDWF  74,F
174A:  BNC   177E
174C:  INCF   75,F
174E:  BNZ   177E
1750:  INCF   76,F
1752:  BNZ   177E
1754:  INCF   77,F
1756:  BRA    177E
1758:  MOVF   71,W
175A:  IORLW  80
175C:  SUBWF  76,F
175E:  BC    177C
1760:  MOVLW  01
1762:  SUBWF  77,F
1764:  BC    177C
1766:  INCF   77,F
1768:  MOVF   71,W
176A:  IORLW  80
176C:  ADDWF  76,F
176E:  MOVF   72,W
1770:  ADDWF  75,F
1772:  BNC   1746
1774:  INCF   76,F
1776:  BNZ   1746
1778:  INCF   77,F
177A:  BRA    1746
177C:  BSF    03.0
177E:  DECFSZ 78,F
1780:  BRA    1784
1782:  BRA    179A
1784:  BCF    FD8.0
1786:  RLCF   74,F
1788:  RLCF   75,F
178A:  RLCF   76,F
178C:  RLCF   77,F
178E:  BCF    FD8.0
1790:  RLCF   03,F
1792:  RLCF   02,F
1794:  RLCF   01,F
1796:  RLCF   79,F
1798:  BRA    170E
179A:  BTFSS  79.0
179C:  BRA    17AA
179E:  BCF    FD8.0
17A0:  RRCF   01,F
17A2:  RRCF   02,F
17A4:  RRCF   03,F
17A6:  RRCF   79,F
17A8:  BRA    17AE
17AA:  DECF   00,F
17AC:  BZ    1818
17AE:  BTFSC  79.7
17B0:  BRA    17EE
17B2:  BCF    FD8.0
17B4:  RLCF   74,F
17B6:  RLCF   75,F
17B8:  RLCF   76,F
17BA:  RLCF   77,F
17BC:  MOVF   73,W
17BE:  SUBWF  74,F
17C0:  BC    17D0
17C2:  MOVLW  01
17C4:  SUBWF  75,F
17C6:  BC    17D0
17C8:  SUBWF  76,F
17CA:  BC    17D0
17CC:  SUBWF  77,F
17CE:  BNC   1804
17D0:  MOVF   72,W
17D2:  SUBWF  75,F
17D4:  BC    17E0
17D6:  MOVLW  01
17D8:  SUBWF  76,F
17DA:  BC    17E0
17DC:  SUBWF  77,F
17DE:  BNC   1804
17E0:  MOVF   71,W
17E2:  IORLW  80
17E4:  SUBWF  76,F
17E6:  BC    17EE
17E8:  MOVLW  01
17EA:  SUBWF  77,F
17EC:  BNC   1804
17EE:  INCF   03,F
17F0:  BNZ   1804
17F2:  INCF   02,F
17F4:  BNZ   1804
17F6:  INCF   01,F
17F8:  BNZ   1804
17FA:  INCF   00,F
17FC:  BZ    1818
17FE:  RRCF   01,F
1800:  RRCF   02,F
1802:  RRCF   03,F
1804:  MOVFF  6D,78
1808:  MOVF   71,W
180A:  XORWF  78,F
180C:  BTFSS  78.7
180E:  BRA    1814
1810:  BSF    01.7
1812:  BRA    1820
1814:  BCF    01.7
1816:  BRA    1820
1818:  CLRF   00
181A:  CLRF   01
181C:  CLRF   02
181E:  CLRF   03
1820:  NOP   
1822:  RETLW  00
*
1B98:  MOVLW  8E
1B9A:  MOVWF  00
1B9C:  MOVFF  62,01
1BA0:  MOVFF  61,02
1BA4:  CLRF   03
1BA6:  MOVF   01,F
1BA8:  BNZ   1BBC
1BAA:  MOVFF  02,01
1BAE:  CLRF   02
1BB0:  MOVLW  08
1BB2:  SUBWF  00,F
1BB4:  MOVF   01,F
1BB6:  BNZ   1BBC
1BB8:  CLRF   00
1BBA:  BRA    1BCC
1BBC:  BCF    FD8.0
1BBE:  BTFSC  01.7
1BC0:  BRA    1BCA
1BC2:  RLCF   02,F
1BC4:  RLCF   01,F
1BC6:  DECF   00,F
1BC8:  BRA    1BBC
1BCA:  BCF    01.7
1BCC:  NOP   
1BCE:  RETLW  00
1BD0:  MOVF   6E,W
1BD2:  BTFSC  FD8.2
1BD4:  BRA    1CB8
1BD6:  MOVWF  00
1BD8:  MOVF   72,W
1BDA:  BTFSC  FD8.2
1BDC:  BRA    1CB8
1BDE:  ADDWF  00,F
1BE0:  BNC   1BEA
1BE2:  MOVLW  81
1BE4:  ADDWF  00,F
1BE6:  BC    1CB8
1BE8:  BRA    1BF2
1BEA:  MOVLW  7F
1BEC:  SUBWF  00,F
1BEE:  BNC   1CB8
1BF0:  BZ    1CB8
1BF2:  MOVFF  6F,76
1BF6:  MOVF   73,W
1BF8:  XORWF  76,F
1BFA:  BSF    6F.7
1BFC:  BSF    73.7
1BFE:  MOVF   71,W
1C00:  MULWF  75
1C02:  MOVFF  FF4,78
1C06:  MOVF   70,W
1C08:  MULWF  74
1C0A:  MOVFF  FF4,03
1C0E:  MOVFF  FF3,77
1C12:  MULWF  75
1C14:  MOVF   FF3,W
1C16:  ADDWF  78,F
1C18:  MOVF   FF4,W
1C1A:  ADDWFC 77,F
1C1C:  MOVLW  00
1C1E:  ADDWFC 03,F
1C20:  MOVF   71,W
1C22:  MULWF  74
1C24:  MOVF   FF3,W
1C26:  ADDWF  78,F
1C28:  MOVF   FF4,W
1C2A:  ADDWFC 77,F
1C2C:  MOVLW  00
1C2E:  CLRF   02
1C30:  ADDWFC 03,F
1C32:  ADDWFC 02,F
1C34:  MOVF   6F,W
1C36:  MULWF  75
1C38:  MOVF   FF3,W
1C3A:  ADDWF  77,F
1C3C:  MOVF   FF4,W
1C3E:  ADDWFC 03,F
1C40:  MOVLW  00
1C42:  ADDWFC 02,F
1C44:  MOVF   6F,W
1C46:  MULWF  74
1C48:  MOVF   FF3,W
1C4A:  ADDWF  03,F
1C4C:  MOVF   FF4,W
1C4E:  ADDWFC 02,F
1C50:  MOVLW  00
1C52:  CLRF   01
1C54:  ADDWFC 01,F
1C56:  MOVF   71,W
1C58:  MULWF  73
1C5A:  MOVF   FF3,W
1C5C:  ADDWF  77,F
1C5E:  MOVF   FF4,W
1C60:  ADDWFC 03,F
1C62:  MOVLW  00
1C64:  ADDWFC 02,F
1C66:  ADDWFC 01,F
1C68:  MOVF   70,W
1C6A:  MULWF  73
1C6C:  MOVF   FF3,W
1C6E:  ADDWF  03,F
1C70:  MOVF   FF4,W
1C72:  ADDWFC 02,F
1C74:  MOVLW  00
1C76:  ADDWFC 01,F
1C78:  MOVF   6F,W
1C7A:  MULWF  73
1C7C:  MOVF   FF3,W
1C7E:  ADDWF  02,F
1C80:  MOVF   FF4,W
1C82:  ADDWFC 01,F
1C84:  INCF   00,F
1C86:  BTFSC  01.7
1C88:  BRA    1C94
1C8A:  RLCF   77,F
1C8C:  RLCF   03,F
1C8E:  RLCF   02,F
1C90:  RLCF   01,F
1C92:  DECF   00,F
1C94:  MOVLW  00
1C96:  BTFSS  77.7
1C98:  BRA    1CAE
1C9A:  INCF   03,F
1C9C:  ADDWFC 02,F
1C9E:  ADDWFC 01,F
1CA0:  MOVF   01,W
1CA2:  BNZ   1CAE
1CA4:  MOVF   02,W
1CA6:  BNZ   1CAE
1CA8:  MOVF   03,W
1CAA:  BNZ   1CAE
1CAC:  INCF   00,F
1CAE:  BTFSC  76.7
1CB0:  BSF    01.7
1CB2:  BTFSS  76.7
1CB4:  BCF    01.7
1CB6:  BRA    1CC0
1CB8:  CLRF   00
1CBA:  CLRF   01
1CBC:  CLRF   02
1CBE:  CLRF   03
1CC0:  NOP   
1CC2:  RETLW  00
1CC4:  MOVF   6E,W
1CC6:  SUBLW  B6
1CC8:  MOVWF  6E
1CCA:  CLRF   03
1CCC:  MOVFF  6F,72
1CD0:  BSF    6F.7
1CD2:  BCF    FD8.0
1CD4:  RRCF   6F,F
1CD6:  RRCF   70,F
1CD8:  RRCF   71,F
1CDA:  RRCF   03,F
1CDC:  RRCF   02,F
1CDE:  RRCF   01,F
1CE0:  RRCF   00,F
1CE2:  DECFSZ 6E,F
1CE4:  BRA    1CD2
1CE6:  BTFSS  72.7
1CE8:  BRA    1D00
1CEA:  COMF   00,F
1CEC:  COMF   01,F
1CEE:  COMF   02,F
1CF0:  COMF   03,F
1CF2:  INCF   00,F
1CF4:  BTFSC  FD8.2
1CF6:  INCF   01,F
1CF8:  BTFSC  FD8.2
1CFA:  INCF   02,F
1CFC:  BTFSC  FD8.2
1CFE:  INCF   03,F
1D00:  RETLW  00
1D02:  CLRF   00
1D04:  CLRF   01
1D06:  CLRF   02
1D08:  CLRF   03
1D0A:  CLRF   76
1D0C:  CLRF   77
1D0E:  CLRF   78
1D10:  CLRF   79
1D12:  MOVF   75,W
1D14:  IORWF  74,W
1D16:  IORWF  73,W
1D18:  IORWF  72,W
1D1A:  BZ    1D74
1D1C:  MOVLW  20
1D1E:  MOVWF  7A
1D20:  BCF    FD8.0
1D22:  RLCF   6E,F
1D24:  RLCF   6F,F
1D26:  RLCF   70,F
1D28:  RLCF   71,F
1D2A:  RLCF   76,F
1D2C:  RLCF   77,F
1D2E:  RLCF   78,F
1D30:  RLCF   79,F
1D32:  MOVF   75,W
1D34:  SUBWF  79,W
1D36:  BNZ   1D48
1D38:  MOVF   74,W
1D3A:  SUBWF  78,W
1D3C:  BNZ   1D48
1D3E:  MOVF   73,W
1D40:  SUBWF  77,W
1D42:  BNZ   1D48
1D44:  MOVF   72,W
1D46:  SUBWF  76,W
1D48:  BNC   1D68
1D4A:  MOVF   72,W
1D4C:  SUBWF  76,F
1D4E:  MOVF   73,W
1D50:  BTFSS  FD8.0
1D52:  INCFSZ 73,W
1D54:  SUBWF  77,F
1D56:  MOVF   74,W
1D58:  BTFSS  FD8.0
1D5A:  INCFSZ 74,W
1D5C:  SUBWF  78,F
1D5E:  MOVF   75,W
1D60:  BTFSS  FD8.0
1D62:  INCFSZ 75,W
1D64:  SUBWF  79,F
1D66:  BSF    FD8.0
1D68:  RLCF   00,F
1D6A:  RLCF   01,F
1D6C:  RLCF   02,F
1D6E:  RLCF   03,F
1D70:  DECFSZ 7A,F
1D72:  BRA    1D20
1D74:  NOP   
1D76:  CLRF   FEA
1D78:  MOVLW  76
1D7A:  MOVWF  FE9
1D7C:  RETLW  00
1D7E:  MOVF   FE9,W
1D80:  MOVWF  66
1D82:  MOVF   65,W
1D84:  MOVWF  68
1D86:  BZ    1DBA
1D88:  MOVFF  64,71
1D8C:  MOVFF  63,70
1D90:  MOVFF  62,6F
1D94:  MOVFF  61,6E
1D98:  CLRF   75
1D9A:  CLRF   74
1D9C:  MOVLW  20
1D9E:  MOVWF  73
1DA0:  MOVLW  82
1DA2:  MOVWF  72
1DA4:  RCALL  1BD0
1DA6:  MOVFF  03,64
1DAA:  MOVFF  02,63
1DAE:  MOVFF  01,62
1DB2:  MOVFF  00,61
1DB6:  DECFSZ 68,F
1DB8:  BRA    1D88
1DBA:  MOVFF  64,71
1DBE:  MOVFF  63,70
1DC2:  MOVFF  62,6F
1DC6:  MOVFF  61,6E
1DCA:  RCALL  1CC4
1DCC:  MOVFF  03,64
1DD0:  MOVFF  02,63
1DD4:  MOVFF  01,62
1DD8:  MOVFF  00,61
1DDC:  BTFSS  64.7
1DDE:  BRA    1DFA
1DE0:  DECF   66,F
1DE2:  BSF    66.5
1DE4:  COMF   61,F
1DE6:  COMF   62,F
1DE8:  COMF   63,F
1DEA:  COMF   64,F
1DEC:  INCF   61,F
1DEE:  BTFSC  FD8.2
1DF0:  INCF   62,F
1DF2:  BTFSC  FD8.2
1DF4:  INCF   63,F
1DF6:  BTFSC  FD8.2
1DF8:  INCF   64,F
1DFA:  MOVLW  3B
1DFC:  MOVWF  6D
1DFE:  MOVLW  9A
1E00:  MOVWF  6C
1E02:  MOVLW  CA
1E04:  MOVWF  6B
1E06:  CLRF   6A
1E08:  MOVLW  0A
1E0A:  MOVWF  68
1E0C:  MOVF   65,W
1E0E:  BTFSC  FD8.2
1E10:  INCF   66,F
1E12:  MOVFF  64,71
1E16:  MOVFF  63,70
1E1A:  MOVFF  62,6F
1E1E:  MOVFF  61,6E
1E22:  MOVFF  6D,75
1E26:  MOVFF  6C,74
1E2A:  MOVFF  6B,73
1E2E:  MOVFF  6A,72
1E32:  RCALL  1D02
1E34:  MOVF   01,W
1E36:  MOVFF  FEF,61
1E3A:  MOVFF  FEC,62
1E3E:  MOVFF  FEC,63
1E42:  MOVFF  FEC,64
1E46:  MOVF   00,F
1E48:  BNZ   1E68
1E4A:  INCF   65,W
1E4C:  SUBWF  68,W
1E4E:  BZ    1E68
1E50:  MOVF   66,W
1E52:  BZ    1E6C
1E54:  ANDLW  0F
1E56:  SUBWF  68,W
1E58:  BZ    1E5C
1E5A:  BC    1ED2
1E5C:  BTFSC  66.7
1E5E:  BRA    1ED2
1E60:  BTFSC  66.6
1E62:  BRA    1E6C
1E64:  MOVLW  20
1E66:  BRA    1EC8
1E68:  MOVLW  20
1E6A:  ANDWF  66,F
1E6C:  BTFSS  66.5
1E6E:  BRA    1E8A
1E70:  BCF    66.5
1E72:  MOVF   65,W
1E74:  BTFSS  FD8.2
1E76:  DECF   66,F
1E78:  MOVF   00,W
1E7A:  MOVWF  66
1E7C:  MOVLW  2D
1E7E:  MOVWF  6E
1E80:  CALL   12E8
1E84:  MOVF   66,W
1E86:  MOVWF  00
1E88:  CLRF   66
1E8A:  MOVF   65,W
1E8C:  SUBWF  68,W
1E8E:  BNZ   1EA6
1E90:  MOVF   00,W
1E92:  MOVWF  66
1E94:  MOVLW  2E
1E96:  MOVWF  6E
1E98:  CALL   12E8
1E9C:  MOVF   66,W
1E9E:  MOVWF  00
1EA0:  MOVLW  20
1EA2:  ANDWF  66,F
1EA4:  MOVLW  00
1EA6:  MOVLW  30
1EA8:  BTFSS  66.5
1EAA:  BRA    1EC8
1EAC:  BCF    66.5
1EAE:  MOVF   65,W
1EB0:  BTFSS  FD8.2
1EB2:  DECF   66,F
1EB4:  MOVF   00,W
1EB6:  MOVWF  66
1EB8:  MOVLW  2D
1EBA:  MOVWF  6E
1EBC:  CALL   12E8
1EC0:  MOVF   66,W
1EC2:  MOVWF  00
1EC4:  CLRF   66
1EC6:  MOVLW  30
1EC8:  ADDWF  00,F
1ECA:  MOVFF  00,6E
1ECE:  CALL   12E8
1ED2:  MOVFF  6D,71
1ED6:  MOVFF  6C,70
1EDA:  MOVFF  6B,6F
1EDE:  MOVFF  6A,6E
1EE2:  CLRF   75
1EE4:  CLRF   74
1EE6:  CLRF   73
1EE8:  MOVLW  0A
1EEA:  MOVWF  72
1EEC:  RCALL  1D02
1EEE:  MOVFF  03,6D
1EF2:  MOVFF  02,6C
1EF6:  MOVFF  01,6B
1EFA:  MOVFF  00,6A
1EFE:  DECFSZ 68,F
1F00:  BRA    1E12
1F02:  RETLW  00
*
21BC:  MOVF   01,W
21BE:  MOVFF  54,63
21C2:  MOVLW  64
21C4:  MOVWF  64
21C6:  CALL   13D6
21CA:  MOVFF  00,54
21CE:  MOVF   01,W
21D0:  MOVLW  30
21D2:  BNZ   21E2
21D4:  BTFSS  55.1
21D6:  BRA    21F2
21D8:  BTFSC  55.3
21DA:  BRA    21F2
21DC:  BTFSC  55.4
21DE:  MOVLW  20
21E0:  BRA    21E8
21E2:  BCF    55.3
21E4:  BCF    55.4
21E6:  BSF    55.0
21E8:  ADDWF  01,F
21EA:  MOVF   01,W
21EC:  BTFSS  F9E.4
21EE:  BRA    21EC
21F0:  MOVWF  FAD
21F2:  MOVFF  54,63
21F6:  MOVLW  0A
21F8:  MOVWF  64
21FA:  CALL   13D6
21FE:  MOVFF  00,54
2202:  MOVF   01,W
2204:  MOVLW  30
2206:  BNZ   2214
2208:  BTFSC  55.3
220A:  BRA    221E
220C:  BTFSS  55.0
220E:  BRA    221E
2210:  BTFSC  55.4
2212:  MOVLW  20
2214:  ADDWF  01,F
2216:  MOVF   01,W
2218:  BTFSS  F9E.4
221A:  BRA    2218
221C:  MOVWF  FAD
221E:  MOVLW  30
2220:  ADDWF  54,F
2222:  MOVF   54,W
2224:  BTFSS  F9E.4
2226:  BRA    2224
2228:  MOVWF  FAD
222A:  RETLW  00
222C:  MOVF   FE9,W
222E:  MOVWF  59
2230:  MOVF   58,W
2232:  MOVWF  5B
2234:  BZ    2268
2236:  MOVFF  57,71
223A:  MOVFF  56,70
223E:  MOVFF  55,6F
2242:  MOVFF  54,6E
2246:  CLRF   75
2248:  CLRF   74
224A:  MOVLW  20
224C:  MOVWF  73
224E:  MOVLW  82
2250:  MOVWF  72
2252:  RCALL  1BD0
2254:  MOVFF  03,57
2258:  MOVFF  02,56
225C:  MOVFF  01,55
2260:  MOVFF  00,54
2264:  DECFSZ 5B,F
2266:  BRA    2236
2268:  MOVFF  57,71
226C:  MOVFF  56,70
2270:  MOVFF  55,6F
2274:  MOVFF  54,6E
2278:  RCALL  1CC4
227A:  MOVFF  03,57
227E:  MOVFF  02,56
2282:  MOVFF  01,55
2286:  MOVFF  00,54
228A:  BTFSS  57.7
228C:  BRA    22A8
228E:  DECF   59,F
2290:  BSF    59.5
2292:  COMF   54,F
2294:  COMF   55,F
2296:  COMF   56,F
2298:  COMF   57,F
229A:  INCF   54,F
229C:  BTFSC  FD8.2
229E:  INCF   55,F
22A0:  BTFSC  FD8.2
22A2:  INCF   56,F
22A4:  BTFSC  FD8.2
22A6:  INCF   57,F
22A8:  MOVLW  3B
22AA:  MOVWF  60
22AC:  MOVLW  9A
22AE:  MOVWF  5F
22B0:  MOVLW  CA
22B2:  MOVWF  5E
22B4:  CLRF   5D
22B6:  MOVLW  0A
22B8:  MOVWF  5B
22BA:  MOVF   58,W
22BC:  BTFSC  FD8.2
22BE:  INCF   59,F
22C0:  MOVFF  57,71
22C4:  MOVFF  56,70
22C8:  MOVFF  55,6F
22CC:  MOVFF  54,6E
22D0:  MOVFF  60,75
22D4:  MOVFF  5F,74
22D8:  MOVFF  5E,73
22DC:  MOVFF  5D,72
22E0:  RCALL  1D02
22E2:  MOVF   01,W
22E4:  MOVFF  FEF,54
22E8:  MOVFF  FEC,55
22EC:  MOVFF  FEC,56
22F0:  MOVFF  FEC,57
22F4:  MOVF   00,F
22F6:  BNZ   2316
22F8:  INCF   58,W
22FA:  SUBWF  5B,W
22FC:  BZ    2316
22FE:  MOVF   59,W
2300:  BZ    231A
2302:  ANDLW  0F
2304:  SUBWF  5B,W
2306:  BZ    230A
2308:  BC    2380
230A:  BTFSC  59.7
230C:  BRA    2380
230E:  BTFSC  59.6
2310:  BRA    231A
2312:  MOVLW  20
2314:  BRA    2376
2316:  MOVLW  20
2318:  ANDWF  59,F
231A:  BTFSS  59.5
231C:  BRA    2338
231E:  BCF    59.5
2320:  MOVF   58,W
2322:  BTFSS  FD8.2
2324:  DECF   59,F
2326:  MOVF   00,W
2328:  MOVWF  59
232A:  MOVLW  2D
232C:  BTFSS  F9E.4
232E:  BRA    232C
2330:  MOVWF  FAD
2332:  MOVF   59,W
2334:  MOVWF  00
2336:  CLRF   59
2338:  MOVF   58,W
233A:  SUBWF  5B,W
233C:  BNZ   2354
233E:  MOVF   00,W
2340:  MOVWF  59
2342:  MOVLW  2E
2344:  BTFSS  F9E.4
2346:  BRA    2344
2348:  MOVWF  FAD
234A:  MOVF   59,W
234C:  MOVWF  00
234E:  MOVLW  20
2350:  ANDWF  59,F
2352:  MOVLW  00
2354:  MOVLW  30
2356:  BTFSS  59.5
2358:  BRA    2376
235A:  BCF    59.5
235C:  MOVF   58,W
235E:  BTFSS  FD8.2
2360:  DECF   59,F
2362:  MOVF   00,W
2364:  MOVWF  59
2366:  MOVLW  2D
2368:  BTFSS  F9E.4
236A:  BRA    2368
236C:  MOVWF  FAD
236E:  MOVF   59,W
2370:  MOVWF  00
2372:  CLRF   59
2374:  MOVLW  30
2376:  ADDWF  00,F
2378:  MOVF   00,W
237A:  BTFSS  F9E.4
237C:  BRA    237A
237E:  MOVWF  FAD
2380:  MOVFF  60,71
2384:  MOVFF  5F,70
2388:  MOVFF  5E,6F
238C:  MOVFF  5D,6E
2390:  CLRF   75
2392:  CLRF   74
2394:  CLRF   73
2396:  MOVLW  0A
2398:  MOVWF  72
239A:  RCALL  1D02
239C:  MOVFF  03,60
23A0:  MOVFF  02,5F
23A4:  MOVFF  01,5E
23A8:  MOVFF  00,5D
23AC:  DECFSZ 5B,F
23AE:  BRA    22C0
23B0:  RETLW  00
*
325E:  MOVFF  FF2,0E
3262:  BCF    FF2.7
3264:  ADDWF  FE8,W
3266:  ADDLW  83
3268:  MOVWF  FF6
326A:  MOVLW  32
326C:  MOVWF  FF7
326E:  BTFSC  FD8.0
3270:  INCF   FF7,F
3272:  TBLRD*-
3274:  MOVF   FF5,W
3276:  MOVWF  FFA
3278:  TBLRD*
327A:  MOVF   FF5,W
327C:  BTFSC  0E.7
327E:  BSF    FF2.7
3280:  MOVWF  FF9
3282:  DATA 8A,30
3284:  DATA A8,30
3286:  DATA CE,30
3288:  DATA EC,30
*
3DA6:  MOVFF  FF2,0E
3DAA:  BCF    FF2.7
3DAC:  ADDWF  FE8,W
3DAE:  ADDLW  CB
3DB0:  MOVWF  FF6
3DB2:  MOVLW  3D
3DB4:  MOVWF  FF7
3DB6:  BTFSC  FD8.0
3DB8:  INCF   FF7,F
3DBA:  TBLRD*-
3DBC:  MOVF   FF5,W
3DBE:  MOVWF  FFA
3DC0:  TBLRD*
3DC2:  MOVF   FF5,W
3DC4:  BTFSC  0E.7
3DC6:  BSF    FF2.7
3DC8:  MOVWF  FF9
3DCA:  DATA FE,3C
3DCC:  DATA 16,3D
3DCE:  DATA 2E,3D
3DD0:  DATA 46,3D
3DD2:  MOVFF  FF2,0E
3DD6:  BCF    FF2.7
3DD8:  ADDWF  FE8,W
3DDA:  ADDLW  F7
3DDC:  MOVWF  FF6
3DDE:  MOVLW  3D
3DE0:  MOVWF  FF7
3DE2:  BTFSC  FD8.0
3DE4:  INCF   FF7,F
3DE6:  TBLRD*-
3DE8:  MOVF   FF5,W
3DEA:  MOVWF  FFA
3DEC:  TBLRD*
3DEE:  MOVF   FF5,W
3DF0:  BTFSC  0E.7
3DF2:  BSF    FF2.7
3DF4:  MOVWF  FF9
3DF6:  DATA 78,3D
3DF8:  DATA 7C,3D
3DFA:  DATA 80,3D
3DFC:  DATA 82,3D
*
4070:  MOVFF  FF2,0E
4074:  BCF    FF2.7
4076:  ADDWF  FE8,W
4078:  ADDLW  95
407A:  MOVWF  FF6
407C:  MOVLW  40
407E:  MOVWF  FF7
4080:  BTFSC  FD8.0
4082:  INCF   FF7,F
4084:  TBLRD*-
4086:  MOVF   FF5,W
4088:  MOVWF  FFA
408A:  TBLRD*
408C:  MOVF   FF5,W
408E:  BTFSC  0E.7
4090:  BSF    FF2.7
4092:  MOVWF  FF9
4094:  DATA 00,3F
4096:  DATA 2E,3F
4098:  DATA 54,3F
409A:  DATA 72,3F
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0)  
.................... #list 
....................  
.................... #fuses HS, WDT, WDT32768, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST 
.................... #use delay(clock=8000000, restart_wdt) 
*
0AFA:  CLRF   FEA
0AFC:  MOVLW  75
0AFE:  MOVWF  FE9
0B00:  MOVF   FEF,W
0B02:  BZ    0B28
0B04:  MOVLW  02
0B06:  MOVWF  01
0B08:  MOVLW  BF
0B0A:  MOVWF  00
0B0C:  CLRWDT
0B0E:  DECFSZ 00,F
0B10:  BRA    0B0C
0B12:  DECFSZ 01,F
0B14:  BRA    0B08
0B16:  MOVLW  96
0B18:  MOVWF  00
0B1A:  DECFSZ 00,F
0B1C:  BRA    0B1A
0B1E:  NOP   
0B20:  NOP   
0B22:  CLRWDT
0B24:  DECFSZ FEF,F
0B26:  BRA    0B04
0B28:  RETLW  00
*
0B48:  MOVLW  09
0B4A:  SUBWF  76,F
0B4C:  BNC   0B64
0B4E:  CLRF   FEA
0B50:  MOVLW  76
0B52:  MOVWF  FE9
0B54:  BCF    FD8.0
0B56:  RRCF   FEF,F
0B58:  MOVF   FEF,W
0B5A:  BZ    0B64
0B5C:  BRA    0B60
0B5E:  CLRWDT
0B60:  DECFSZ FEF,F
0B62:  BRA    0B5E
0B64:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6, rcv=PIN_C7, stream=FT232) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //definicion de direcciones 
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL) 
*
0BF0:  MOVLW  08
0BF2:  MOVWF  01
0BF4:  NOP   
0BF6:  NOP   
0BF8:  NOP   
0BFA:  BCF    F8B.3
0BFC:  BCF    F94.3
0BFE:  NOP   
0C00:  NOP   
0C02:  NOP   
0C04:  RLCF   6A,F
0C06:  BCF    F8B.4
0C08:  BTFSC  FD8.0
0C0A:  BSF    F94.4
0C0C:  BTFSS  FD8.0
0C0E:  BCF    F94.4
0C10:  BSF    F94.3
0C12:  BTFSS  F82.3
0C14:  BRA    0C12
0C16:  DECFSZ 01,F
0C18:  BRA    0BF4
0C1A:  NOP   
0C1C:  NOP   
0C1E:  BCF    F8B.3
0C20:  BCF    F94.3
0C22:  NOP   
0C24:  BSF    F94.4
0C26:  NOP   
0C28:  NOP   
0C2A:  NOP   
0C2C:  NOP   
0C2E:  NOP   
0C30:  NOP   
0C32:  BSF    F94.3
0C34:  BTFSS  F82.3
0C36:  BRA    0C34
0C38:  CLRF   01
0C3A:  NOP   
0C3C:  NOP   
0C3E:  NOP   
0C40:  BTFSC  F82.4
0C42:  BSF    01.0
0C44:  BCF    F8B.3
0C46:  BCF    F94.3
0C48:  BCF    F8B.4
0C4A:  BCF    F94.4
0C4C:  RETLW  00
0C4E:  MOVLW  08
0C50:  MOVWF  6B
0C52:  MOVFF  00,6C
0C56:  BSF    F94.4
0C58:  NOP   
0C5A:  NOP   
0C5C:  NOP   
0C5E:  BSF    F94.3
0C60:  BTFSS  F82.3
0C62:  BRA    0C60
0C64:  BTFSC  F82.4
0C66:  BSF    FD8.0
0C68:  BTFSS  F82.4
0C6A:  BCF    FD8.0
0C6C:  RLCF   01,F
0C6E:  NOP   
0C70:  NOP   
0C72:  BCF    F94.3
0C74:  BCF    F8B.3
0C76:  DECFSZ 6B,F
0C78:  BRA    0C56
0C7A:  BSF    F94.4
0C7C:  NOP   
0C7E:  NOP   
0C80:  NOP   
0C82:  BCF    F8B.4
0C84:  MOVF   6C,W
0C86:  BTFSS  FD8.2
0C88:  BCF    F94.4
0C8A:  NOP   
0C8C:  BSF    F94.3
0C8E:  BTFSS  F82.3
0C90:  BRA    0C8E
0C92:  NOP   
0C94:  NOP   
0C96:  BCF    F8B.3
0C98:  BCF    F94.3
0C9A:  NOP   
0C9C:  NOP   
0C9E:  NOP   
0CA0:  BCF    F8B.4
0CA2:  BCF    F94.4
0CA4:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ENABLEINTERRUPTS   0x02 
.................... #define PCF8583_ENABLEALARM        0x91 
....................  
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... //disable_interrupts(GLOBAL);  //antes de escribir deshabilito interrupciones, y al final las habilito de nuevo para evitar conflictos 
.................... i2c_start(); 
*
0CC6:  BSF    F94.4
0CC8:  NOP   
0CCA:  NOP   
0CCC:  BSF    F94.3
0CCE:  NOP   
0CD0:  NOP   
0CD2:  NOP   
0CD4:  BCF    F8B.4
0CD6:  BCF    F94.4
0CD8:  NOP   
0CDA:  NOP   
0CDC:  BCF    F8B.3
0CDE:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
0CE0:  MOVLW  A0
0CE2:  MOVWF  6A
0CE4:  RCALL  0BF0
.................... i2c_write(address); 
0CE6:  MOVFF  68,6A
0CEA:  RCALL  0BF0
.................... i2c_write(data); 
0CEC:  MOVFF  69,6A
0CF0:  RCALL  0BF0
.................... i2c_stop(); 
0CF2:  BCF    F94.4
0CF4:  NOP   
0CF6:  BSF    F94.3
0CF8:  BTFSS  F82.3
0CFA:  BRA    0CF8
0CFC:  NOP   
0CFE:  NOP   
0D00:  NOP   
0D02:  NOP   
0D04:  NOP   
0D06:  BSF    F94.4
0D08:  NOP   
0D0A:  NOP   
.................... //enable_interrupts(GLOBAL); 
.................... } 
0D0C:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... //disable_interrupts(GLOBAL); 
.................... i2c_start(); 
*
195E:  BSF    F94.4
1960:  NOP   
1962:  NOP   
1964:  BSF    F94.3
1966:  NOP   
1968:  NOP   
196A:  NOP   
196C:  BCF    F8B.4
196E:  BCF    F94.4
1970:  NOP   
1972:  NOP   
1974:  BCF    F8B.3
1976:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
1978:  MOVLW  A0
197A:  MOVWF  6A
197C:  CALL   0BF0
.................... i2c_write(address); 
1980:  MOVFF  68,6A
1984:  CALL   0BF0
.................... i2c_start(); 
1988:  BSF    F94.4
198A:  NOP   
198C:  NOP   
198E:  BSF    F94.3
1990:  NOP   
1992:  NOP   
1994:  NOP   
1996:  BTFSS  F82.3
1998:  BRA    1996
199A:  BCF    F8B.4
199C:  BCF    F94.4
199E:  NOP   
19A0:  NOP   
19A2:  BCF    F8B.3
19A4:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
19A6:  MOVLW  A1
19A8:  MOVWF  6A
19AA:  CALL   0BF0
.................... retval = i2c_read(0); 
19AE:  CLRF   00
19B0:  CALL   0C4E
19B4:  MOVFF  01,69
.................... i2c_stop(); 
19B8:  BCF    F94.4
19BA:  NOP   
19BC:  BSF    F94.3
19BE:  BTFSS  F82.3
19C0:  BRA    19BE
19C2:  NOP   
19C4:  NOP   
19C6:  NOP   
19C8:  NOP   
19CA:  NOP   
19CC:  BSF    F94.4
19CE:  NOP   
19D0:  NOP   
.................... //enable_interrupts(GLOBAL); 
.................... return(retval); 
19D2:  MOVFF  69,01
.................... } 
19D6:  GOTO   1B68 (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
*
1464:  CLRF   68
1466:  CLRF   69
1468:  RCALL  0CC6
.................... } 
146A:  GOTO   3FB0 (RETURN)
....................  
.................... void PCF8583_init_enableinterrupts(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_ENABLEINTERRUPTS); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
0CA6:  CLRF   63
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
0CA8:  MOVF   62,W
0CAA:  SUBLW  09
0CAC:  BC    0CB8
....................      { 
....................       value -= 10; 
0CAE:  MOVLW  0A
0CB0:  SUBWF  62,F
....................       retval += 0x10; 
0CB2:  MOVLW  10
0CB4:  ADDWF  63,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
0CB6:  BRA    0CBE
....................      { 
....................       retval += value; 
0CB8:  MOVF   62,W
0CBA:  ADDWF  63,F
....................       break; 
0CBC:  BRA    0CC0
....................      } 
....................    } 
0CBE:  BRA    0CA8
....................  
.................... return(retval); 
0CC0:  MOVFF  63,01
.................... } 
0CC4:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
1938:  MOVFF  6B,6C
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
193C:  BCF    FD8.0
193E:  RRCF   6C,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
1940:  MOVLW  78
1942:  ANDWF  6C,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
1944:  RRCF   6C,W
1946:  MOVWF  00
1948:  RRCF   00,F
194A:  MOVLW  3F
194C:  ANDWF  00,F
194E:  MOVF   00,W
1950:  ADDWF  6C,W
1952:  MOVWF  6D
1954:  MOVF   6B,W
1956:  ANDLW  0F
1958:  ADDWF  6D,W
195A:  MOVWF  01
....................  
.................... } 
195C:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
146E:  MOVF   52,W
1470:  MOVWF  FE9
1472:  MOVFF  53,FEA
1476:  MOVFF  FEF,59
147A:  MOVFF  59,62
147E:  RCALL  0CA6
1480:  MOVFF  01,54
.................... bcd_min = bin2bcd(dt->minutes); 
1484:  MOVLW  01
1486:  ADDWF  52,W
1488:  MOVWF  FE9
148A:  MOVLW  00
148C:  ADDWFC 53,W
148E:  MOVWF  FEA
1490:  MOVFF  FEF,59
1494:  MOVFF  59,62
1498:  RCALL  0CA6
149A:  MOVFF  01,55
.................... bcd_hrs = bin2bcd(dt->hours); 
149E:  MOVLW  02
14A0:  ADDWF  52,W
14A2:  MOVWF  FE9
14A4:  MOVLW  00
14A6:  ADDWFC 53,W
14A8:  MOVWF  FEA
14AA:  MOVFF  FEF,59
14AE:  MOVFF  59,62
14B2:  CALL   0CA6
14B6:  MOVFF  01,56
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
14BA:  MOVLW  03
14BC:  ADDWF  52,W
14BE:  MOVWF  FE9
14C0:  MOVLW  00
14C2:  ADDWFC 53,W
14C4:  MOVWF  FEA
14C6:  MOVFF  FEF,59
14CA:  MOVFF  59,62
14CE:  CALL   0CA6
14D2:  MOVLW  05
14D4:  ADDWF  52,W
14D6:  MOVWF  FE9
14D8:  MOVLW  00
14DA:  ADDWFC 53,W
14DC:  MOVWF  FEA
14DE:  SWAPF  FEF,W
14E0:  MOVWF  00
14E2:  RLCF   00,F
14E4:  RLCF   00,F
14E6:  MOVLW  C0
14E8:  ANDWF  00,F
14EA:  MOVF   00,W
14EC:  IORWF  01,W
14EE:  MOVWF  57
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
14F0:  MOVLW  04
14F2:  ADDWF  52,W
14F4:  MOVWF  FE9
14F6:  MOVLW  00
14F8:  ADDWFC 53,W
14FA:  MOVWF  FEA
14FC:  MOVFF  FEF,59
1500:  MOVFF  59,62
1504:  CALL   0CA6
1508:  MOVLW  06
150A:  ADDWF  52,W
150C:  MOVWF  FE9
150E:  MOVLW  00
1510:  ADDWFC 53,W
1512:  MOVWF  FEA
1514:  SWAPF  FEF,W
1516:  MOVWF  00
1518:  RLCF   00,F
151A:  MOVLW  E0
151C:  ANDWF  00,F
151E:  MOVF   00,W
1520:  IORWF  01,W
1522:  MOVWF  58
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
1524:  CLRF   68
1526:  MOVLW  80
1528:  MOVWF  69
152A:  CALL   0CC6
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... //disable_interrupts(GLOBAL); 
.................... i2c_start(); 
152E:  BSF    F94.4
1530:  NOP   
1532:  NOP   
1534:  BSF    F94.3
1536:  NOP   
1538:  NOP   
153A:  NOP   
153C:  BCF    F8B.4
153E:  BCF    F94.4
1540:  NOP   
1542:  NOP   
1544:  BCF    F8B.3
1546:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
1548:  MOVLW  A0
154A:  MOVWF  6A
154C:  CALL   0BF0
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
1550:  MOVLW  01
1552:  MOVWF  6A
1554:  CALL   0BF0
.................... i2c_write(0x00);               // Set 100's reg = 0 
1558:  CLRF   6A
155A:  CALL   0BF0
.................... i2c_write(bcd_sec); 
155E:  MOVFF  54,6A
1562:  CALL   0BF0
.................... i2c_write(bcd_min); 
1566:  MOVFF  55,6A
156A:  CALL   0BF0
.................... i2c_write(bcd_hrs); 
156E:  MOVFF  56,6A
1572:  CALL   0BF0
.................... i2c_write(bcd_day); 
1576:  MOVFF  57,6A
157A:  CALL   0BF0
.................... i2c_write(bcd_mon); 
157E:  MOVFF  58,6A
1582:  CALL   0BF0
.................... i2c_stop(); 
1586:  BCF    F94.4
1588:  NOP   
158A:  BSF    F94.3
158C:  BTFSS  F82.3
158E:  BRA    158C
1590:  NOP   
1592:  NOP   
1594:  NOP   
1596:  NOP   
1598:  NOP   
159A:  BSF    F94.4
159C:  NOP   
159E:  NOP   
.................... //enable_interrupts(GLOBAL); 
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
15A0:  MOVLW  05
15A2:  ADDWF  52,W
15A4:  MOVWF  FE9
15A6:  MOVLW  00
15A8:  ADDWFC 53,W
15AA:  MOVWF  FEA
15AC:  MOVFF  FEF,59
15B0:  MOVLW  10
15B2:  MOVWF  68
15B4:  MOVFF  59,69
15B8:  CALL   0CC6
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
15BC:  CLRF   68
15BE:  CLRF   69
15C0:  CALL   0CC6
.................... } 
15C4:  GOTO   3FBA (RETURN)
....................  
....................  
.................... void PCF8583_set_alarmtime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
0D0E:  MOVF   5A,W
0D10:  MOVWF  FE9
0D12:  MOVFF  5B,FEA
0D16:  MOVFF  FEF,61
0D1A:  MOVFF  61,62
0D1E:  RCALL  0CA6
0D20:  MOVFF  01,5C
.................... bcd_min = bin2bcd(dt->minutes); 
0D24:  MOVLW  01
0D26:  ADDWF  5A,W
0D28:  MOVWF  FE9
0D2A:  MOVLW  00
0D2C:  ADDWFC 5B,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEF,61
0D34:  MOVFF  61,62
0D38:  RCALL  0CA6
0D3A:  MOVFF  01,5D
.................... bcd_hrs = bin2bcd(dt->hours); 
0D3E:  MOVLW  02
0D40:  ADDWF  5A,W
0D42:  MOVWF  FE9
0D44:  MOVLW  00
0D46:  ADDWFC 5B,W
0D48:  MOVWF  FEA
0D4A:  MOVFF  FEF,61
0D4E:  MOVFF  61,62
0D52:  RCALL  0CA6
0D54:  MOVFF  01,5E
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
0D58:  MOVLW  03
0D5A:  ADDWF  5A,W
0D5C:  MOVWF  FE9
0D5E:  MOVLW  00
0D60:  ADDWFC 5B,W
0D62:  MOVWF  FEA
0D64:  MOVFF  FEF,61
0D68:  MOVFF  61,62
0D6C:  RCALL  0CA6
0D6E:  MOVLW  05
0D70:  ADDWF  5A,W
0D72:  MOVWF  FE9
0D74:  MOVLW  00
0D76:  ADDWFC 5B,W
0D78:  MOVWF  FEA
0D7A:  SWAPF  FEF,W
0D7C:  MOVWF  00
0D7E:  RLCF   00,F
0D80:  RLCF   00,F
0D82:  MOVLW  C0
0D84:  ANDWF  00,F
0D86:  MOVF   00,W
0D88:  IORWF  01,W
0D8A:  MOVWF  5F
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
0D8C:  MOVLW  04
0D8E:  ADDWF  5A,W
0D90:  MOVWF  FE9
0D92:  MOVLW  00
0D94:  ADDWFC 5B,W
0D96:  MOVWF  FEA
0D98:  MOVFF  FEF,61
0D9C:  MOVFF  61,62
0DA0:  RCALL  0CA6
0DA2:  MOVLW  06
0DA4:  ADDWF  5A,W
0DA6:  MOVWF  FE9
0DA8:  MOVLW  00
0DAA:  ADDWFC 5B,W
0DAC:  MOVWF  FEA
0DAE:  SWAPF  FEF,W
0DB0:  MOVWF  00
0DB2:  RLCF   00,F
0DB4:  MOVLW  E0
0DB6:  ANDWF  00,F
0DB8:  MOVF   00,W
0DBA:  IORWF  01,W
0DBC:  MOVWF  60
....................  
.................... //disable_interrupts(GLOBAL); 
....................  
.................... PCF8583_write_byte(PCF8583_ALARM_100S_REG,0x00); 
0DBE:  MOVLW  09
0DC0:  MOVWF  68
0DC2:  CLRF   69
0DC4:  RCALL  0CC6
.................... PCF8583_write_byte(PCF8583_ALARM_SECS_REG,bcd_sec); 
0DC6:  MOVLW  0A
0DC8:  MOVWF  68
0DCA:  MOVFF  5C,69
0DCE:  RCALL  0CC6
.................... PCF8583_write_byte(PCF8583_ALARM_MINS_REG,bcd_min); 
0DD0:  MOVLW  0B
0DD2:  MOVWF  68
0DD4:  MOVFF  5D,69
0DD8:  RCALL  0CC6
.................... PCF8583_write_byte(PCF8583_ALARM_HOURS_REG,bcd_hrs); 
0DDA:  MOVLW  0C
0DDC:  MOVWF  68
0DDE:  MOVFF  5E,69
0DE2:  RCALL  0CC6
.................... PCF8583_write_byte(PCF8583_ALARM_DATE_REG,bcd_day); 
0DE4:  MOVLW  0D
0DE6:  MOVWF  68
0DE8:  MOVFF  5F,69
0DEC:  RCALL  0CC6
.................... PCF8583_write_byte(PCF8583_ALARM_MONTHS_REG,bcd_mon); 
0DEE:  MOVLW  0E
0DF0:  MOVWF  68
0DF2:  MOVFF  60,69
0DF6:  RCALL  0CC6
....................  
.................... //enable_interrupts(GLOBAL); 
.................... } 
0DF8:  RETLW  00
....................  
....................  
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... //disable_interrupts(GLOBAL); 
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
*
19DA:  BSF    F94.4
19DC:  NOP   
19DE:  NOP   
19E0:  BSF    F94.3
19E2:  NOP   
19E4:  NOP   
19E6:  NOP   
19E8:  BCF    F8B.4
19EA:  BCF    F94.4
19EC:  NOP   
19EE:  NOP   
19F0:  BCF    F8B.3
19F2:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
19F4:  MOVLW  A0
19F6:  MOVWF  6A
19F8:  CALL   0BF0
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
19FC:  MOVLW  02
19FE:  MOVWF  6A
1A00:  CALL   0BF0
.................... i2c_start(); 
1A04:  BSF    F94.4
1A06:  NOP   
1A08:  NOP   
1A0A:  BSF    F94.3
1A0C:  NOP   
1A0E:  NOP   
1A10:  NOP   
1A12:  BTFSS  F82.3
1A14:  BRA    1A12
1A16:  BCF    F8B.4
1A18:  BCF    F94.4
1A1A:  NOP   
1A1C:  NOP   
1A1E:  BCF    F8B.3
1A20:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
1A22:  MOVLW  A1
1A24:  MOVWF  6A
1A26:  CALL   0BF0
....................  
.................... bcd_sec = i2c_read(); 
1A2A:  MOVLW  01
1A2C:  MOVWF  00
1A2E:  CALL   0C4E
1A32:  MOVFF  01,63
.................... bcd_min = i2c_read(); 
1A36:  MOVLW  01
1A38:  MOVWF  00
1A3A:  CALL   0C4E
1A3E:  MOVFF  01,64
.................... bcd_hrs = i2c_read(); 
1A42:  MOVLW  01
1A44:  MOVWF  00
1A46:  CALL   0C4E
1A4A:  MOVFF  01,65
.................... bcd_day = i2c_read(); 
1A4E:  MOVLW  01
1A50:  MOVWF  00
1A52:  CALL   0C4E
1A56:  MOVFF  01,66
.................... bcd_mon = i2c_read(0); 
1A5A:  CLRF   00
1A5C:  CALL   0C4E
1A60:  MOVFF  01,67
.................... i2c_stop(); 
1A64:  BCF    F94.4
1A66:  NOP   
1A68:  BSF    F94.3
1A6A:  BTFSS  F82.3
1A6C:  BRA    1A6A
1A6E:  NOP   
1A70:  NOP   
1A72:  NOP   
1A74:  NOP   
1A76:  NOP   
1A78:  BSF    F94.4
1A7A:  NOP   
1A7C:  NOP   
....................  
.................... //enable_interrupts(GLOBAL); 
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
1A7E:  MOVFF  5F,01
1A82:  MOVFF  60,03
1A86:  MOVFF  5F,68
1A8A:  MOVFF  60,69
1A8E:  MOVFF  63,6B
1A92:  RCALL  1938
1A94:  MOVFF  69,FEA
1A98:  MOVFF  68,FE9
1A9C:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
1AA0:  MOVLW  01
1AA2:  ADDWF  5F,W
1AA4:  MOVWF  01
1AA6:  MOVLW  00
1AA8:  ADDWFC 60,W
1AAA:  MOVWF  03
1AAC:  MOVFF  01,68
1AB0:  MOVWF  69
1AB2:  MOVFF  64,6B
1AB6:  RCALL  1938
1AB8:  MOVFF  69,FEA
1ABC:  MOVFF  68,FE9
1AC0:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
1AC4:  MOVLW  02
1AC6:  ADDWF  5F,W
1AC8:  MOVWF  01
1ACA:  MOVLW  00
1ACC:  ADDWFC 60,W
1ACE:  MOVWF  03
1AD0:  MOVFF  01,68
1AD4:  MOVWF  69
1AD6:  MOVF   65,W
1AD8:  ANDLW  3F
1ADA:  MOVWF  6A
1ADC:  MOVWF  6B
1ADE:  RCALL  1938
1AE0:  MOVFF  69,FEA
1AE4:  MOVFF  68,FE9
1AE8:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
1AEC:  MOVLW  03
1AEE:  ADDWF  5F,W
1AF0:  MOVWF  01
1AF2:  MOVLW  00
1AF4:  ADDWFC 60,W
1AF6:  MOVWF  03
1AF8:  MOVFF  01,68
1AFC:  MOVWF  69
1AFE:  MOVF   66,W
1B00:  ANDLW  3F
1B02:  MOVWF  6A
1B04:  MOVWF  6B
1B06:  RCALL  1938
1B08:  MOVFF  69,FEA
1B0C:  MOVFF  68,FE9
1B10:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
1B14:  MOVLW  04
1B16:  ADDWF  5F,W
1B18:  MOVWF  01
1B1A:  MOVLW  00
1B1C:  ADDWFC 60,W
1B1E:  MOVWF  03
1B20:  MOVFF  01,68
1B24:  MOVWF  69
1B26:  MOVF   67,W
1B28:  ANDLW  1F
1B2A:  MOVWF  6A
1B2C:  MOVWF  6B
1B2E:  RCALL  1938
1B30:  MOVFF  69,FEA
1B34:  MOVFF  68,FE9
1B38:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
1B3C:  MOVLW  06
1B3E:  ADDWF  5F,W
1B40:  MOVWF  FE9
1B42:  MOVLW  00
1B44:  ADDWFC 60,W
1B46:  MOVWF  FEA
1B48:  SWAPF  67,W
1B4A:  MOVWF  00
1B4C:  RRCF   00,F
1B4E:  MOVLW  07
1B50:  ANDWF  00,F
1B52:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
1B56:  SWAPF  66,W
1B58:  MOVWF  61
1B5A:  RRCF   61,F
1B5C:  RRCF   61,F
1B5E:  MOVLW  03
1B60:  ANDWF  61,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
1B62:  MOVLW  10
1B64:  MOVWF  68
1B66:  BRA    195E
1B68:  MOVFF  01,62
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
1B6C:  MOVF   62,W
1B6E:  ANDLW  03
1B70:  SUBWF  61,W
1B72:  BZ    1B78
1B74:  INCF   62,F
1B76:  BRA    1B6C
....................  
.................... dt->year = year; 
1B78:  MOVLW  05
1B7A:  ADDWF  5F,W
1B7C:  MOVWF  FE9
1B7E:  MOVLW  00
1B80:  ADDWFC 60,W
1B82:  MOVWF  FEA
1B84:  MOVFF  62,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
1B88:  MOVLW  10
1B8A:  MOVWF  68
1B8C:  MOVFF  62,69
1B90:  CALL   0CC6
....................  
.................... } 
1B94:  GOTO   1F16 (RETURN)
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0B2A:  SWAPF  76,W
0B2C:  ANDLW  F0
0B2E:  MOVWF  00
0B30:  MOVLW  0F
0B32:  ANDWF  F81,W
0B34:  IORWF  00,W
0B36:  MOVWF  F81
....................       delay_cycles(1); 
0B38:  NOP   
....................       lcd.enable = 1; 
0B3A:  BSF    F81.3
....................       delay_us(2); 
0B3C:  CLRWDT
0B3E:  NOP   
0B40:  NOP   
0B42:  NOP   
....................       lcd.enable = 0; 
0B44:  BCF    F81.3
.................... } 
0B46:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
0B66:  BCF    F81.2
....................       delay_us(3000); 
0B68:  CLRWDT
0B6A:  MOVLW  02
0B6C:  MOVWF  75
0B6E:  RCALL  0AFA
0B70:  MOVLW  09
0B72:  MOVWF  75
0B74:  MOVLW  6D
0B76:  MOVWF  76
0B78:  RCALL  0B48
0B7A:  DECFSZ 75,F
0B7C:  BRA    0B74
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
0B7E:  BTFSS  73.0
0B80:  BCF    F81.2
0B82:  BTFSC  73.0
0B84:  BSF    F81.2
....................       delay_cycles(1); 
0B86:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
0B88:  NOP   
....................       lcd.enable = 0; 
0B8A:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
0B8C:  SWAPF  74,W
0B8E:  MOVWF  75
0B90:  MOVLW  0F
0B92:  ANDWF  75,F
0B94:  MOVFF  75,76
0B98:  RCALL  0B2A
....................       lcd_send_nibble(n & 0xf); 
0B9A:  MOVF   74,W
0B9C:  ANDLW  0F
0B9E:  MOVWF  75
0BA0:  MOVWF  76
0BA2:  RCALL  0B2A
.................... } 
0BA4:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
0BA6:  MOVLW  03
0BA8:  MOVWF  F93
....................     lcd.rs = 0; 
0BAA:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
0BAC:  BCF    F81.3
....................     delay_ms(50); 
0BAE:  MOVLW  32
0BB0:  MOVWF  75
0BB2:  RCALL  0AFA
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
0BB4:  MOVLW  02
0BB6:  MOVWF  76
0BB8:  RCALL  0B2A
....................     delay_ms(5); 
0BBA:  MOVLW  05
0BBC:  MOVWF  75
0BBE:  RCALL  0AFA
....................     for(i=0;i<=3;++i) 
0BC0:  CLRF   52
0BC2:  MOVF   52,W
0BC4:  SUBLW  03
0BC6:  BNC   0BEC
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
0BC8:  CLRF   03
0BCA:  MOVF   52,W
0BCC:  MOVFF  FF2,53
0BD0:  BCF    FF2.7
0BD2:  CALL   0114
0BD6:  BTFSC  53.7
0BD8:  BSF    FF2.7
0BDA:  MOVWF  54
0BDC:  CLRF   73
0BDE:  MOVWF  74
0BE0:  RCALL  0B66
....................         delay_ms(5); } 
0BE2:  MOVLW  05
0BE4:  MOVWF  75
0BE6:  RCALL  0AFA
0BE8:  INCF   52,F
0BEA:  BRA    0BC2
.................... } 
0BEC:  GOTO   3E84 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
12C6:  DECFSZ 70,W
12C8:  BRA    12CC
12CA:  BRA    12D2
....................      address=lcd_line_two; 
12CC:  MOVLW  40
12CE:  MOVWF  71
....................    else 
12D0:  BRA    12D4
....................      address=0; 
12D2:  CLRF   71
....................    address+=x-1; 
12D4:  MOVLW  01
12D6:  SUBWF  6F,W
12D8:  ADDWF  71,F
....................    lcd_send_byte(0,0x80|address); 
12DA:  MOVF   71,W
12DC:  IORLW  80
12DE:  MOVWF  72
12E0:  CLRF   73
12E2:  MOVWF  74
12E4:  RCALL  0B66
.................... } 
12E6:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
12E8:  MOVF   6E,W
12EA:  XORLW  0C
12EC:  BZ    12F8
12EE:  XORLW  06
12F0:  BZ    130A
12F2:  XORLW  02
12F4:  BZ    1316
12F6:  BRA    1320
....................      case '\f'   : lcd_send_byte(0,1); 
12F8:  CLRF   73
12FA:  MOVLW  01
12FC:  MOVWF  74
12FE:  RCALL  0B66
....................                    delay_ms(2); 
1300:  MOVLW  02
1302:  MOVWF  75
1304:  CALL   0AFA
....................                                            break; 
1308:  BRA    132C
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
130A:  MOVLW  01
130C:  MOVWF  6F
130E:  MOVLW  02
1310:  MOVWF  70
1312:  RCALL  12C6
1314:  BRA    132C
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
1316:  CLRF   73
1318:  MOVLW  10
131A:  MOVWF  74
131C:  RCALL  0B66
131E:  BRA    132C
....................      default     : lcd_send_byte(1,c);     break; 
1320:  MOVLW  01
1322:  MOVWF  73
1324:  MOVFF  6E,74
1328:  RCALL  0B66
132A:  BRA    132C
....................    } 
.................... } 
132C:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
15C8:  BCF    F92.5
15CA:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
15CC:  CLRWDT
15CE:  MOVLW  02
15D0:  MOVWF  68
15D2:  MOVLW  F7
15D4:  MOVWF  76
15D6:  CALL   0B48
15DA:  DECFSZ 68,F
15DC:  BRA    15D2
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
15DE:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
15E0:  CLRWDT
15E2:  MOVLW  02
15E4:  MOVWF  68
15E6:  MOVLW  F7
15E8:  MOVWF  76
15EA:  CALL   0B48
15EE:  DECFSZ 68,F
15F0:  BRA    15E6
....................  output_float(ONE_WIRE_PIN); 
15F2:  BSF    F92.5
.................... } 
15F4:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
15F6:  CLRF   69
15F8:  MOVF   69,W
15FA:  SUBLW  07
15FC:  BNC   1632
....................  { 
....................   output_low(ONE_WIRE_PIN); 
15FE:  BCF    F92.5
1600:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1602:  CLRWDT
1604:  NOP   
1606:  NOP   
1608:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
160A:  BCF    FD8.0
160C:  RRCF   68,F
160E:  BC    1614
1610:  BCF    F89.5
1612:  BRA    1616
1614:  BSF    F89.5
1616:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1618:  CLRWDT
161A:  MOVLW  27
161C:  MOVWF  00
161E:  DECFSZ 00,F
1620:  BRA    161E
1622:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1624:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1626:  CLRWDT
1628:  NOP   
162A:  NOP   
162C:  NOP   
....................  } 
162E:  INCF   69,F
1630:  BRA    15F8
.................... } 
1632:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
1634:  CLRF   68
1636:  MOVF   68,W
1638:  SUBLW  07
163A:  BNC   1676
....................  { 
....................   output_low(ONE_WIRE_PIN); 
163C:  BCF    F92.5
163E:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1640:  CLRWDT
1642:  NOP   
1644:  NOP   
1646:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1648:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
164A:  CLRWDT
164C:  MOVLW  04
164E:  MOVWF  00
1650:  DECFSZ 00,F
1652:  BRA    1650
1654:  NOP   
1656:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
1658:  BSF    F92.5
165A:  BTFSC  F80.5
165C:  BRA    1662
165E:  BCF    FD8.0
1660:  BRA    1664
1662:  BSF    FD8.0
1664:  RRCF   69,F
....................   delay_us( 120 ); // wait until end of read slot. 
1666:  CLRWDT
1668:  MOVLW  4F
166A:  MOVWF  00
166C:  DECFSZ 00,F
166E:  BRA    166C
1670:  NOP   
....................  } 
1672:  INCF   68,F
1674:  BRA    1636
....................  
....................  return( data ); 
1676:  MOVFF  69,01
.................... } 
167A:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read() 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
1824:  CLRF   5F
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
1826:  RCALL  15C8
....................  onewire_write(0xCC); //Instrucción SKIP ROM (selecciona todos los dispositivos del 1wire) 
1828:  MOVLW  CC
182A:  MOVWF  68
182C:  RCALL  15F6
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
182E:  MOVLW  44
1830:  MOVWF  68
1832:  RCALL  15F6
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
1834:  MOVF   5F,F
1836:  BNZ   1840
1838:  RCALL  1634
183A:  MOVFF  01,5F
183E:  BRA    1834
....................  
....................  onewire_reset(); 
1840:  RCALL  15C8
....................  onewire_write(0xCC); 
1842:  MOVLW  CC
1844:  MOVWF  68
1846:  RCALL  15F6
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
1848:  MOVLW  BE
184A:  MOVWF  68
184C:  RCALL  15F6
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
184E:  RCALL  1634
1850:  MOVFF  01,60
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
1854:  RCALL  1634
1856:  MOVFF  01,61
....................  
....................  temp3 = make16(temp2, temp1); // 
185A:  MOVFF  61,63
185E:  MOVFF  60,62
....................  result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
1862:  MOVFF  63,69
1866:  MOVFF  62,68
186A:  BRA    167C
186C:  MOVFF  00,68
1870:  MOVFF  01,69
1874:  MOVFF  02,6A
1878:  MOVFF  03,6B
187C:  MOVFF  03,6F
1880:  MOVFF  02,6E
1884:  MOVFF  01,6D
1888:  MOVFF  00,6C
188C:  CLRF   73
188E:  CLRF   72
1890:  CLRF   71
1892:  MOVLW  80
1894:  MOVWF  70
1896:  RCALL  16C8
1898:  MOVFF  03,67
189C:  MOVFF  02,66
18A0:  MOVFF  01,65
18A4:  MOVFF  00,64
.................... // result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution 
....................  
....................  //delay_ms(200); 
....................  return(result); 
18A8:  MOVFF  64,00
18AC:  MOVFF  65,01
18B0:  MOVFF  66,02
18B4:  MOVFF  67,03
.................... } 
18B8:  RETLW  00
....................  
.................... #include "kbd2.c" 
.................... /*-------------------------------------------*\ 
....................  |  KBD2.C                                   | 
....................  |  Autor: Pedro Mª Jiménez                  | 
....................  |  (c) Microsystems Engineering (Bilbao)    | 
.................... \*-------------------------------------------*/ 
....................  
.................... // Funciones para la gestión del teclado de la Trainer PLUS. 
....................  
.................... // char kbd_getc()	Devuelve el código ASCII de la tecla pulsada. 
.................... //			Si no se pulsó ninguna, devuelve 0. 
....................  
....................  
.................... // Conexiones del teclado. 
.................... /* 
....................             RB0 RB1 RB2 
....................              ^   ^   ^ 
....................              |   |   | 
....................            |---|---|---| 
....................   RB4 ---> | 1 | 2 | 3 | 
....................            |---|---|---| 
....................   RB5 ---> | 4 | 5 | 6 | 
....................            |---|---|---| 
....................   RB6 ---> | 7 | 8 | 9 | 
....................            |---|---|---| 
....................   RB7 ---> | * | 0 | # | 
....................            |---|---|---| 
.................... */ 
....................  
.................... // Caracteres ASCII asociados a cada tecla: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................                           
.................... int const TECLAS[4][3] = {{1,2,3}, 
....................                           {4,5,6}, 
....................                           {7,8,9}, 
....................                           {10,0,10}}; 
....................  
.................... #byte kbd_port_b = 0xf83 
....................  
....................  
.................... int kbd_getc() 
.................... { 
....................   int tecla=11; 
*
132E:  MOVLW  0B
1330:  MOVWF  59
....................   int f,c,t,i,j; 
....................  
....................   port_b_pullups(true); 
1332:  BCF    FF1.7
....................   set_tris_d(0b00001111); // RB7-RB4 salidas, RB3-RB0 entradas 
1334:  MOVLW  0F
1336:  MOVWF  F95
....................  
....................   for(f=0x10, i=0; i<4; f<<=1, i++) 
1338:  MOVLW  10
133A:  MOVWF  5A
133C:  CLRF   5D
133E:  MOVF   5D,W
1340:  SUBLW  03
1342:  BNC   13CE
....................   { 
....................     for(c=0x01, j=0; j<3; c<<=1, j++) 
1344:  MOVLW  01
1346:  MOVWF  5B
1348:  CLRF   5E
134A:  MOVF   5E,W
134C:  SUBLW  02
134E:  BNC   13BE
....................     { 
....................       kbd_port_b = ~f; 
1350:  MOVFF  5A,F83
1354:  COMF   F83,F
....................       delay_cycles(1); 
1356:  NOP   
....................       t = kbd_port_b & 0x0F; 
1358:  MOVF   F83,W
135A:  ANDLW  0F
135C:  MOVWF  5C
....................       t = ~(t | 0xF0); 
135E:  MOVF   5C,W
1360:  IORLW  F0
1362:  XORLW  FF
1364:  MOVWF  5C
....................       if(t == c) 
1366:  MOVF   5B,W
1368:  SUBWF  5C,W
136A:  BNZ   13B6
....................       { 
....................         delay_ms(20); 
136C:  MOVLW  14
136E:  MOVWF  75
1370:  CALL   0AFA
....................         tecla=TECLAS[i][j]; 
1374:  MOVF   5D,W
1376:  MULLW  03
1378:  MOVF   FF3,W
137A:  CLRF   60
137C:  MOVWF  5F
137E:  CLRF   03
1380:  MOVF   5E,W
1382:  ADDWF  5F,W
1384:  MOVWF  01
1386:  MOVF   60,W
1388:  ADDWFC 03,F
138A:  MOVF   01,W
138C:  MOVFF  FF2,61
1390:  BCF    FF2.7
1392:  CALL   0132
1396:  BTFSC  61.7
1398:  BSF    FF2.7
139A:  MOVWF  59
....................         while(t==c) 
....................         { 
139C:  MOVF   5B,W
139E:  SUBWF  5C,W
13A0:  BNZ   13B4
....................           restart_wdt(); 
13A2:  CLRWDT
....................           t = kbd_port_b & 0x0F; 
13A4:  MOVF   F83,W
13A6:  ANDLW  0F
13A8:  MOVWF  5C
....................           t = ~(t | 0xF0); 
13AA:  MOVF   5C,W
13AC:  IORLW  F0
13AE:  XORLW  FF
13B0:  MOVWF  5C
....................         } 
13B2:  BRA    139C
....................         break; 
13B4:  BRA    13BE
....................       } 
....................     } 
13B6:  BCF    FD8.0
13B8:  RLCF   5B,F
13BA:  INCF   5E,F
13BC:  BRA    134A
....................     if(tecla!=11) 
13BE:  MOVF   59,W
13C0:  SUBLW  0B
13C2:  BZ    13C6
....................       break; 
13C4:  BRA    13CE
....................   } 
13C6:  BCF    FD8.0
13C8:  RLCF   5A,F
13CA:  INCF   5D,F
13CC:  BRA    133E
....................  
....................   port_b_pullups(false); 
13CE:  BSF    FF1.7
....................   return tecla; 
13D0:  MOVFF  59,01
.................... } 
13D4:  RETLW  00
....................  
.................... #include "datos_funciones.c"  // Los datos usados en el proyecto así como las funciones serán definidas previamente en este archivo 
.................... /* 
....................    En este archivo predefino todos los datos y método que usaré a lo largo del programa. Esto se hace así por 
....................    la forma en que se ejecutan los archivos en C, que necesitan que los métodos o las variables hayan sido 
....................    declaradas previamente, aunque no tomen ningún valor (o método vacíos). Sin embargo, los métodos tendrán 
....................    el funcionamiento que se les dé más adelante al definirlos de nuevo. 
.................... */ 
....................  
.................... // Niveles de temperatura, cloro y turbidez deseada, además de las variables con las que se controlará la dosificación de cloro y floculante 
.................... float tempDeseada,cloroDeseado,turbidezDeseada,difCloro, difTurbidez; 
.................... // Variables de inicio y fin del ciclo de la depuradora, flag del menú e indicador de depuradora activa 
.................... int horaInicio, minutoInicio, horaFin, minutoFin,flag,flagDepuradora,depuradoraOn,auxiliar,ntpl,n1,n2,n3,n4; 
....................    // auxiliar es un valor usado para comparar al introducir hora inicial 
....................    // ntpl se usa para comprobar el número de teclas pulsadas al introducir la hora inicial 
....................    // n1-n4 se usan al introducir la hora inicial, para las distintas cifras  
.................... // Aquí se guardan los días de la semana como cadenas de caracteres 
.................... char weekday[10]; 
.................... // Variables del tiempo actual en el PCF y la hora de alarma. Este tipo de dato fue definido en el fichero del PCF8583 
.................... date_time_t dt,dtalarm; 
.................... // Métodos definidos en feeprom.c 
.................... void escribeEeprom(); 
.................... void leeEeprom(); 
.................... // Métodos definidos en el archivo principal 
.................... void comprobar_temperatura(); 
.................... void mostrar_lcd(); 
.................... void mostrar_rs232(); 
.................... void dosificadores(); 
.................... void funcionaDepuradora(); 
.................... // Métodos usados por la interfaz 
.................... void menuAlarma(); 
.................... void menuTemperatura(); 
.................... void menuCloro(); 
.................... void menuTurbidez(); 
.................... void menu(); 
....................  
.................... #include "feeprom.c"          // Funciones relativas a lectura y escritura en eeprom 
.................... void escribeEeprom(){ 
....................    /* 
....................       Este método escribirá ciertos datos referidos a la configuración de la piscina en memoria EEPROM, tanto en la interna del PIC 
....................       como en una memoria I2C externa incluida en el modelo de Proteus. Estos datos a guardar serán 4 enteros (hora y minuto tanto 
....................       del encendido como del apagado de la depuradora) y 3 flotantes (valores deseados de temperatura, cloro y turbidez). Los flotantes 
....................       los guardaremos en 4 posiciones de memoria al ser de 32 bits, haciendo esta división con ayuda de un puntero que señale al inicio 
....................       de dónde están almacenados los flotantes en memoria. Se comenzará la escritura con un flag de inicio que determinará si hemos 
....................       escrito o no en la memoria para luego reconocer estos datos en lecturas sucesivas. 
....................       Se usará este método cada vez que el usuario modifique en el menú los datos relativos al funcionamiento del sistema. 
....................    */ 
....................    int ptd,pcd,ptbd; // Punteros para las variables flotantes, serán de tipo int que son 8 bits, justo como en las posiciones de memoria 
....................    ptd=&tempDeseada; 
*
27F2:  MOVLW  19
27F4:  MOVWF  59
....................    pcd=&cloroDeseado; 
27F6:  MOVLW  1D
27F8:  MOVWF  5A
....................    ptbd=&turbidezDeseada; 
27FA:  MOVLW  21
27FC:  MOVWF  5B
....................    // Empezamos con un flag para reconocer que hemos escrito en memoria 
....................    write_eeprom(0x9E,0xAB); 
27FE:  MOVLW  9E
2800:  MOVWF  FA9
2802:  MOVLW  AB
2804:  MOVWF  FA8
2806:  BCF    FA6.6
2808:  BCF    FA6.7
280A:  BSF    FA6.2
280C:  MOVFF  FF2,00
2810:  BCF    FF2.7
2812:  MOVLB  F
2814:  MOVLW  55
2816:  MOVWF  FA7
2818:  MOVLW  AA
281A:  MOVWF  FA7
281C:  BSF    FA6.1
281E:  BTFSC  FA6.1
2820:  BRA    281E
2822:  BCF    FA6.2
2824:  MOVF   00,W
2826:  IORWF  FF2,F
....................    write_eeprom(0x9F,0xCD); 
2828:  MOVLW  9F
282A:  MOVWF  FA9
282C:  MOVLW  CD
282E:  MOVWF  FA8
2830:  BCF    FA6.6
2832:  BCF    FA6.7
2834:  BSF    FA6.2
2836:  MOVFF  FF2,00
283A:  BCF    FF2.7
283C:  MOVLW  55
283E:  MOVWF  FA7
2840:  MOVLW  AA
2842:  MOVWF  FA7
2844:  BSF    FA6.1
2846:  BTFSC  FA6.1
2848:  BRA    2846
284A:  BCF    FA6.2
284C:  MOVF   00,W
284E:  IORWF  FF2,F
....................    // Empezamos a escribir en la posición A0 de la memoria eeprom 
....................    write_eeprom(0xA0,horaInicio); 
2850:  MOVLW  A0
2852:  MOVWF  FA9
2854:  MOVFF  2D,FA8
2858:  BCF    FA6.6
285A:  BCF    FA6.7
285C:  BSF    FA6.2
285E:  MOVFF  FF2,00
2862:  BCF    FF2.7
2864:  MOVLW  55
2866:  MOVWF  FA7
2868:  MOVLW  AA
286A:  MOVWF  FA7
286C:  BSF    FA6.1
286E:  BTFSC  FA6.1
2870:  BRA    286E
2872:  BCF    FA6.2
2874:  MOVF   00,W
2876:  IORWF  FF2,F
....................    write_eeprom(0xA1,minutoInicio); 
2878:  MOVLW  A1
287A:  MOVWF  FA9
287C:  MOVFF  2E,FA8
2880:  BCF    FA6.6
2882:  BCF    FA6.7
2884:  BSF    FA6.2
2886:  MOVFF  FF2,00
288A:  BCF    FF2.7
288C:  MOVLW  55
288E:  MOVWF  FA7
2890:  MOVLW  AA
2892:  MOVWF  FA7
2894:  BSF    FA6.1
2896:  BTFSC  FA6.1
2898:  BRA    2896
289A:  BCF    FA6.2
289C:  MOVF   00,W
289E:  IORWF  FF2,F
....................    write_eeprom(0xA2,horaFin); 
28A0:  MOVLW  A2
28A2:  MOVWF  FA9
28A4:  MOVFF  2F,FA8
28A8:  BCF    FA6.6
28AA:  BCF    FA6.7
28AC:  BSF    FA6.2
28AE:  MOVFF  FF2,00
28B2:  BCF    FF2.7
28B4:  MOVLW  55
28B6:  MOVWF  FA7
28B8:  MOVLW  AA
28BA:  MOVWF  FA7
28BC:  BSF    FA6.1
28BE:  BTFSC  FA6.1
28C0:  BRA    28BE
28C2:  BCF    FA6.2
28C4:  MOVF   00,W
28C6:  IORWF  FF2,F
....................    write_eeprom(0xA3,minutoFin); 
28C8:  MOVLW  A3
28CA:  MOVWF  FA9
28CC:  MOVFF  30,FA8
28D0:  BCF    FA6.6
28D2:  BCF    FA6.7
28D4:  BSF    FA6.2
28D6:  MOVFF  FF2,00
28DA:  BCF    FF2.7
28DC:  MOVLW  55
28DE:  MOVWF  FA7
28E0:  MOVLW  AA
28E2:  MOVWF  FA7
28E4:  BSF    FA6.1
28E6:  BTFSC  FA6.1
28E8:  BRA    28E6
28EA:  BCF    FA6.2
28EC:  MOVF   00,W
28EE:  IORWF  FF2,F
....................    write_eeprom(0xA4,*ptd); 
28F0:  CLRF   03
28F2:  MOVFF  59,FE9
28F6:  MOVFF  03,FEA
28FA:  MOVFF  FEF,5C
28FE:  MOVLW  A4
2900:  MOVWF  FA9
2902:  MOVFF  5C,FA8
2906:  BCF    FA6.6
2908:  BCF    FA6.7
290A:  BSF    FA6.2
290C:  MOVFF  FF2,00
2910:  BCF    FF2.7
2912:  MOVLW  55
2914:  MOVWF  FA7
2916:  MOVLW  AA
2918:  MOVWF  FA7
291A:  BSF    FA6.1
291C:  BTFSC  FA6.1
291E:  BRA    291C
2920:  BCF    FA6.2
2922:  MOVF   00,W
2924:  IORWF  FF2,F
....................    write_eeprom(0xA5,*(ptd+1)); 
2926:  MOVLW  01
2928:  ADDWF  59,W
292A:  CLRF   03
292C:  MOVWF  FE9
292E:  MOVFF  03,FEA
2932:  MOVFF  FEF,5C
2936:  MOVLW  A5
2938:  MOVWF  FA9
293A:  MOVFF  5C,FA8
293E:  BCF    FA6.6
2940:  BCF    FA6.7
2942:  BSF    FA6.2
2944:  MOVFF  FF2,00
2948:  BCF    FF2.7
294A:  MOVLW  55
294C:  MOVWF  FA7
294E:  MOVLW  AA
2950:  MOVWF  FA7
2952:  BSF    FA6.1
2954:  BTFSC  FA6.1
2956:  BRA    2954
2958:  BCF    FA6.2
295A:  MOVF   00,W
295C:  IORWF  FF2,F
....................    write_eeprom(0xA6,*(ptd+2)); 
295E:  MOVLW  02
2960:  ADDWF  59,W
2962:  CLRF   03
2964:  MOVWF  FE9
2966:  MOVFF  03,FEA
296A:  MOVFF  FEF,5C
296E:  MOVLW  A6
2970:  MOVWF  FA9
2972:  MOVFF  5C,FA8
2976:  BCF    FA6.6
2978:  BCF    FA6.7
297A:  BSF    FA6.2
297C:  MOVFF  FF2,00
2980:  BCF    FF2.7
2982:  MOVLW  55
2984:  MOVWF  FA7
2986:  MOVLW  AA
2988:  MOVWF  FA7
298A:  BSF    FA6.1
298C:  BTFSC  FA6.1
298E:  BRA    298C
2990:  BCF    FA6.2
2992:  MOVF   00,W
2994:  IORWF  FF2,F
....................    write_eeprom(0xA7,*(ptd+3)); 
2996:  MOVLW  03
2998:  ADDWF  59,W
299A:  CLRF   03
299C:  MOVWF  FE9
299E:  MOVFF  03,FEA
29A2:  MOVFF  FEF,5C
29A6:  MOVLW  A7
29A8:  MOVWF  FA9
29AA:  MOVFF  5C,FA8
29AE:  BCF    FA6.6
29B0:  BCF    FA6.7
29B2:  BSF    FA6.2
29B4:  MOVFF  FF2,00
29B8:  BCF    FF2.7
29BA:  MOVLW  55
29BC:  MOVWF  FA7
29BE:  MOVLW  AA
29C0:  MOVWF  FA7
29C2:  BSF    FA6.1
29C4:  BTFSC  FA6.1
29C6:  BRA    29C4
29C8:  BCF    FA6.2
29CA:  MOVF   00,W
29CC:  IORWF  FF2,F
....................    write_eeprom(0xA8,*pcd); 
29CE:  CLRF   03
29D0:  MOVFF  5A,FE9
29D4:  MOVFF  03,FEA
29D8:  MOVFF  FEF,5C
29DC:  MOVLW  A8
29DE:  MOVWF  FA9
29E0:  MOVFF  5C,FA8
29E4:  BCF    FA6.6
29E6:  BCF    FA6.7
29E8:  BSF    FA6.2
29EA:  MOVFF  FF2,00
29EE:  BCF    FF2.7
29F0:  MOVLW  55
29F2:  MOVWF  FA7
29F4:  MOVLW  AA
29F6:  MOVWF  FA7
29F8:  BSF    FA6.1
29FA:  BTFSC  FA6.1
29FC:  BRA    29FA
29FE:  BCF    FA6.2
2A00:  MOVF   00,W
2A02:  IORWF  FF2,F
....................    write_eeprom(0xA9,*(pcd+1)); 
2A04:  MOVLW  01
2A06:  ADDWF  5A,W
2A08:  CLRF   03
2A0A:  MOVWF  FE9
2A0C:  MOVFF  03,FEA
2A10:  MOVFF  FEF,5C
2A14:  MOVLW  A9
2A16:  MOVWF  FA9
2A18:  MOVFF  5C,FA8
2A1C:  BCF    FA6.6
2A1E:  BCF    FA6.7
2A20:  BSF    FA6.2
2A22:  MOVFF  FF2,00
2A26:  BCF    FF2.7
2A28:  MOVLW  55
2A2A:  MOVWF  FA7
2A2C:  MOVLW  AA
2A2E:  MOVWF  FA7
2A30:  BSF    FA6.1
2A32:  BTFSC  FA6.1
2A34:  BRA    2A32
2A36:  BCF    FA6.2
2A38:  MOVF   00,W
2A3A:  IORWF  FF2,F
....................    write_eeprom(0xAA,*(pcd+2)); 
2A3C:  MOVLW  02
2A3E:  ADDWF  5A,W
2A40:  CLRF   03
2A42:  MOVWF  FE9
2A44:  MOVFF  03,FEA
2A48:  MOVFF  FEF,5C
2A4C:  MOVLW  AA
2A4E:  MOVWF  FA9
2A50:  MOVFF  5C,FA8
2A54:  BCF    FA6.6
2A56:  BCF    FA6.7
2A58:  BSF    FA6.2
2A5A:  MOVFF  FF2,00
2A5E:  BCF    FF2.7
2A60:  MOVLW  55
2A62:  MOVWF  FA7
2A64:  MOVLW  AA
2A66:  MOVWF  FA7
2A68:  BSF    FA6.1
2A6A:  BTFSC  FA6.1
2A6C:  BRA    2A6A
2A6E:  BCF    FA6.2
2A70:  MOVF   00,W
2A72:  IORWF  FF2,F
....................    write_eeprom(0xAB,*(pcd+3)); 
2A74:  MOVLW  03
2A76:  ADDWF  5A,W
2A78:  CLRF   03
2A7A:  MOVWF  FE9
2A7C:  MOVFF  03,FEA
2A80:  MOVFF  FEF,5C
2A84:  MOVLW  AB
2A86:  MOVWF  FA9
2A88:  MOVFF  5C,FA8
2A8C:  BCF    FA6.6
2A8E:  BCF    FA6.7
2A90:  BSF    FA6.2
2A92:  MOVFF  FF2,00
2A96:  BCF    FF2.7
2A98:  MOVLW  55
2A9A:  MOVWF  FA7
2A9C:  MOVLW  AA
2A9E:  MOVWF  FA7
2AA0:  BSF    FA6.1
2AA2:  BTFSC  FA6.1
2AA4:  BRA    2AA2
2AA6:  BCF    FA6.2
2AA8:  MOVF   00,W
2AAA:  IORWF  FF2,F
....................    write_eeprom(0xAC,*ptbd); 
2AAC:  CLRF   03
2AAE:  MOVFF  5B,FE9
2AB2:  MOVFF  03,FEA
2AB6:  MOVFF  FEF,5C
2ABA:  MOVLW  AC
2ABC:  MOVWF  FA9
2ABE:  MOVFF  5C,FA8
2AC2:  BCF    FA6.6
2AC4:  BCF    FA6.7
2AC6:  BSF    FA6.2
2AC8:  MOVFF  FF2,00
2ACC:  BCF    FF2.7
2ACE:  MOVLW  55
2AD0:  MOVWF  FA7
2AD2:  MOVLW  AA
2AD4:  MOVWF  FA7
2AD6:  BSF    FA6.1
2AD8:  BTFSC  FA6.1
2ADA:  BRA    2AD8
2ADC:  BCF    FA6.2
2ADE:  MOVF   00,W
2AE0:  IORWF  FF2,F
....................    write_eeprom(0xAD,*(ptbd+1)); 
2AE2:  MOVLW  01
2AE4:  ADDWF  5B,W
2AE6:  CLRF   03
2AE8:  MOVWF  FE9
2AEA:  MOVFF  03,FEA
2AEE:  MOVFF  FEF,5C
2AF2:  MOVLW  AD
2AF4:  MOVWF  FA9
2AF6:  MOVFF  5C,FA8
2AFA:  BCF    FA6.6
2AFC:  BCF    FA6.7
2AFE:  BSF    FA6.2
2B00:  MOVFF  FF2,00
2B04:  BCF    FF2.7
2B06:  MOVLW  55
2B08:  MOVWF  FA7
2B0A:  MOVLW  AA
2B0C:  MOVWF  FA7
2B0E:  BSF    FA6.1
2B10:  BTFSC  FA6.1
2B12:  BRA    2B10
2B14:  BCF    FA6.2
2B16:  MOVF   00,W
2B18:  IORWF  FF2,F
....................    write_eeprom(0xAE,*(ptbd+2)); 
2B1A:  MOVLW  02
2B1C:  ADDWF  5B,W
2B1E:  CLRF   03
2B20:  MOVWF  FE9
2B22:  MOVFF  03,FEA
2B26:  MOVFF  FEF,5C
2B2A:  MOVLW  AE
2B2C:  MOVWF  FA9
2B2E:  MOVFF  5C,FA8
2B32:  BCF    FA6.6
2B34:  BCF    FA6.7
2B36:  BSF    FA6.2
2B38:  MOVFF  FF2,00
2B3C:  BCF    FF2.7
2B3E:  MOVLW  55
2B40:  MOVWF  FA7
2B42:  MOVLW  AA
2B44:  MOVWF  FA7
2B46:  BSF    FA6.1
2B48:  BTFSC  FA6.1
2B4A:  BRA    2B48
2B4C:  BCF    FA6.2
2B4E:  MOVF   00,W
2B50:  IORWF  FF2,F
....................    write_eeprom(0xAF,*(ptbd+3)); 
2B52:  MOVLW  03
2B54:  ADDWF  5B,W
2B56:  CLRF   03
2B58:  MOVWF  FE9
2B5A:  MOVFF  03,FEA
2B5E:  MOVFF  FEF,5C
2B62:  MOVLW  AF
2B64:  MOVWF  FA9
2B66:  MOVFF  5C,FA8
2B6A:  BCF    FA6.6
2B6C:  BCF    FA6.7
2B6E:  BSF    FA6.2
2B70:  MOVFF  FF2,00
2B74:  BCF    FF2.7
2B76:  MOVLW  55
2B78:  MOVWF  FA7
2B7A:  MOVLW  AA
2B7C:  MOVWF  FA7
2B7E:  BSF    FA6.1
2B80:  BTFSC  FA6.1
2B82:  BRA    2B80
2B84:  BCF    FA6.2
2B86:  MOVF   00,W
2B88:  IORWF  FF2,F
....................  
....................    // Ahora vamos a la memoria I2C 
....................    i2c_start(); 
2B8A:  BSF    F94.4
2B8C:  NOP   
2B8E:  NOP   
2B90:  BSF    F94.3
2B92:  NOP   
2B94:  NOP   
2B96:  NOP   
2B98:  BCF    F8B.4
2B9A:  BCF    F94.4
2B9C:  NOP   
2B9E:  NOP   
2BA0:  BCF    F8B.3
2BA2:  BCF    F94.3
....................    i2c_write(0xAE);  // Esto es AE porque este dispositivo I2C (la eeprom) tiene como dirección 1 0 1 0 A2 A1 A0 0 
2BA4:  MOVLW  AE
2BA6:  MOVWF  6A
2BA8:  MOVLB  0
2BAA:  CALL   0BF0
....................                      // Y como A2, A1 y A0 en el Proteus los he conectado a +5V, estos valdrán 1, por lo que la secuencia será 1010 1110, 
....................                      // o lo que es lo mismo, AE. Esto lo hago así para que la dirección de la memoria externa EEPROM no sea la misma que la 
....................                      // del PCF8583, que es también un dispositivo I2C y su dirección es A0, que sería la de este caso si A2, A1 y A0 fueran a tierra. 
....................    i2c_write(0x00);  // Posición inicial de memoria -> 00A0 
2BAE:  CLRF   6A
2BB0:  CALL   0BF0
....................    i2c_write(0xA0); 
2BB4:  MOVLW  A0
2BB6:  MOVWF  6A
2BB8:  CALL   0BF0
....................    i2c_write(horaInicio); 
2BBC:  MOVFF  2D,6A
2BC0:  CALL   0BF0
....................    i2c_write(minutoInicio); 
2BC4:  MOVFF  2E,6A
2BC8:  CALL   0BF0
....................    i2c_write(horaFin); 
2BCC:  MOVFF  2F,6A
2BD0:  CALL   0BF0
....................    i2c_write(minutoFin); 
2BD4:  MOVFF  30,6A
2BD8:  CALL   0BF0
....................    i2c_write(*ptd); 
2BDC:  CLRF   03
2BDE:  MOVFF  59,FE9
2BE2:  MOVFF  03,FEA
2BE6:  MOVFF  FEF,5C
2BEA:  MOVFF  5C,6A
2BEE:  CALL   0BF0
....................    i2c_write(*(ptd+1)); 
2BF2:  MOVLW  01
2BF4:  ADDWF  59,W
2BF6:  CLRF   03
2BF8:  MOVWF  FE9
2BFA:  MOVFF  03,FEA
2BFE:  MOVFF  FEF,5C
2C02:  MOVFF  5C,6A
2C06:  CALL   0BF0
....................    i2c_write(*(ptd+2)); 
2C0A:  MOVLW  02
2C0C:  ADDWF  59,W
2C0E:  CLRF   03
2C10:  MOVWF  FE9
2C12:  MOVFF  03,FEA
2C16:  MOVFF  FEF,5C
2C1A:  MOVFF  5C,6A
2C1E:  CALL   0BF0
....................    i2c_write(*(ptd+3)); 
2C22:  MOVLW  03
2C24:  ADDWF  59,W
2C26:  CLRF   03
2C28:  MOVWF  FE9
2C2A:  MOVFF  03,FEA
2C2E:  MOVFF  FEF,5C
2C32:  MOVFF  5C,6A
2C36:  CALL   0BF0
....................    i2c_write(*pcd); 
2C3A:  CLRF   03
2C3C:  MOVFF  5A,FE9
2C40:  MOVFF  03,FEA
2C44:  MOVFF  FEF,5C
2C48:  MOVFF  5C,6A
2C4C:  CALL   0BF0
....................    i2c_write(*(pcd+1)); 
2C50:  MOVLW  01
2C52:  ADDWF  5A,W
2C54:  CLRF   03
2C56:  MOVWF  FE9
2C58:  MOVFF  03,FEA
2C5C:  MOVFF  FEF,5C
2C60:  MOVFF  5C,6A
2C64:  CALL   0BF0
....................    i2c_write(*(pcd+2)); 
2C68:  MOVLW  02
2C6A:  ADDWF  5A,W
2C6C:  CLRF   03
2C6E:  MOVWF  FE9
2C70:  MOVFF  03,FEA
2C74:  MOVFF  FEF,5C
2C78:  MOVFF  5C,6A
2C7C:  CALL   0BF0
....................    i2c_write(*(pcd+3)); 
2C80:  MOVLW  03
2C82:  ADDWF  5A,W
2C84:  CLRF   03
2C86:  MOVWF  FE9
2C88:  MOVFF  03,FEA
2C8C:  MOVFF  FEF,5C
2C90:  MOVFF  5C,6A
2C94:  CALL   0BF0
....................    i2c_write(*ptbd); 
2C98:  CLRF   03
2C9A:  MOVFF  5B,FE9
2C9E:  MOVFF  03,FEA
2CA2:  MOVFF  FEF,5C
2CA6:  MOVFF  5C,6A
2CAA:  CALL   0BF0
....................    i2c_write(*(ptbd+1)); 
2CAE:  MOVLW  01
2CB0:  ADDWF  5B,W
2CB2:  CLRF   03
2CB4:  MOVWF  FE9
2CB6:  MOVFF  03,FEA
2CBA:  MOVFF  FEF,5C
2CBE:  MOVFF  5C,6A
2CC2:  CALL   0BF0
....................    i2c_write(*(ptbd+2)); 
2CC6:  MOVLW  02
2CC8:  ADDWF  5B,W
2CCA:  CLRF   03
2CCC:  MOVWF  FE9
2CCE:  MOVFF  03,FEA
2CD2:  MOVFF  FEF,5C
2CD6:  MOVFF  5C,6A
2CDA:  CALL   0BF0
....................    i2c_write(*(ptbd+3)); 
2CDE:  MOVLW  03
2CE0:  ADDWF  5B,W
2CE2:  CLRF   03
2CE4:  MOVWF  FE9
2CE6:  MOVFF  03,FEA
2CEA:  MOVFF  FEF,5C
2CEE:  MOVFF  5C,6A
2CF2:  CALL   0BF0
....................    i2c_stop(); 
2CF6:  BCF    F94.4
2CF8:  NOP   
2CFA:  BSF    F94.3
2CFC:  BTFSS  F82.3
2CFE:  BRA    2CFC
2D00:  NOP   
2D02:  NOP   
2D04:  NOP   
2D06:  NOP   
2D08:  NOP   
2D0A:  BSF    F94.4
2D0C:  NOP   
2D0E:  NOP   
....................    delay_ms(50); 
2D10:  MOVLW  32
2D12:  MOVWF  75
2D14:  CALL   0AFA
....................     
....................    // Inicializo otra vez I2C ahora para escribir el flag (no me deja escribirlo todo seguido) 
....................    i2c_start(); 
2D18:  BSF    F94.4
2D1A:  NOP   
2D1C:  NOP   
2D1E:  BSF    F94.3
2D20:  NOP   
2D22:  NOP   
2D24:  NOP   
2D26:  BCF    F8B.4
2D28:  BCF    F94.4
2D2A:  NOP   
2D2C:  NOP   
2D2E:  BCF    F8B.3
2D30:  BCF    F94.3
....................    i2c_write(0xAE); 
2D32:  MOVLW  AE
2D34:  MOVWF  6A
2D36:  CALL   0BF0
....................    i2c_write(0x00); 
2D3A:  CLRF   6A
2D3C:  CALL   0BF0
....................    i2c_write(0x9E);  // Ahora escribiremos el flag en la posición de memoria 0x9E y 0x9F 
2D40:  MOVLW  9E
2D42:  MOVWF  6A
2D44:  CALL   0BF0
....................    i2c_write(0xAB); 
2D48:  MOVLW  AB
2D4A:  MOVWF  6A
2D4C:  CALL   0BF0
....................    i2c_write(0xCD); 
2D50:  MOVLW  CD
2D52:  MOVWF  6A
2D54:  CALL   0BF0
....................    i2c_stop(); 
2D58:  BCF    F94.4
2D5A:  NOP   
2D5C:  BSF    F94.3
2D5E:  BTFSS  F82.3
2D60:  BRA    2D5E
2D62:  NOP   
2D64:  NOP   
2D66:  NOP   
2D68:  NOP   
2D6A:  NOP   
2D6C:  BSF    F94.4
2D6E:  NOP   
2D70:  NOP   
.................... } 
2D72:  RETLW  00
....................  
.................... void leeEeprom(){ 
....................    /* 
....................       Este método lee los datos guardados en eeprom y los carga en las variables de control del sistema. El método normalmente tratará 
....................       de hacer la lectura en la memoria interna, pero si no encuentra datos introducidos por el usuario (ejemplo, ha habido que cambiar 
....................       el PIC por fallo de funcionamiento), pasará a buscar los datos en la memoria I2C externa, que debería haber quedado intacta. En 
....................       caso de no encontrar datos introducidos por el usuario en ninguna de las dos memorias, el sistema cargará unos valores predefinidos. 
....................       El método se lanzará cada vez que se inicie el funcionamiento del sistema. 
....................    */ 
....................    int ptd, pcd, ptbd, flag1, flag2, flag3, flag4; 
....................    // Punteros para las variables flotantes 
....................    ptd=&tempDeseada; 
*
0DFA:  MOVLW  19
0DFC:  MOVWF  53
....................    pcd=&cloroDeseado; 
0DFE:  MOVLW  1D
0E00:  MOVWF  54
....................    ptbd=&turbidezDeseada; 
0E02:  MOVLW  21
0E04:  MOVWF  55
....................    // Lee donde deberían haberse guardado los flags en la memoria interna 
....................    flag1=read_eeprom(0x9E); 
0E06:  MOVFF  FF2,5A
0E0A:  BCF    FF2.7
0E0C:  MOVLW  9E
0E0E:  MOVWF  FA9
0E10:  BCF    FA6.6
0E12:  BCF    FA6.7
0E14:  BSF    FA6.0
0E16:  MOVF   FA8,W
0E18:  BTFSC  5A.7
0E1A:  BSF    FF2.7
0E1C:  MOVWF  56
....................    flag2=read_eeprom(0x9F); 
0E1E:  MOVFF  FF2,5A
0E22:  BCF    FF2.7
0E24:  MOVLW  9F
0E26:  MOVWF  FA9
0E28:  BCF    FA6.6
0E2A:  BCF    FA6.7
0E2C:  BSF    FA6.0
0E2E:  MOVF   FA8,W
0E30:  BTFSC  5A.7
0E32:  BSF    FF2.7
0E34:  MOVWF  57
....................     
....................    // Leemos en I2C primero para obtener los flags 
....................    i2c_start(); 
0E36:  BSF    F94.4
0E38:  NOP   
0E3A:  NOP   
0E3C:  BSF    F94.3
0E3E:  NOP   
0E40:  NOP   
0E42:  NOP   
0E44:  BCF    F8B.4
0E46:  BCF    F94.4
0E48:  NOP   
0E4A:  NOP   
0E4C:  BCF    F8B.3
0E4E:  BCF    F94.3
....................    i2c_write(0xAE);     // Byte de control de escritura. 
0E50:  MOVLW  AE
0E52:  MOVWF  6A
0E54:  RCALL  0BF0
....................    i2c_write(0x00);     // 2 bytes de dirección 
0E56:  CLRF   6A
0E58:  RCALL  0BF0
....................    i2c_write(0x9E); 
0E5A:  MOVLW  9E
0E5C:  MOVWF  6A
0E5E:  RCALL  0BF0
....................    i2c_start(); 
0E60:  BSF    F94.4
0E62:  NOP   
0E64:  NOP   
0E66:  BSF    F94.3
0E68:  NOP   
0E6A:  NOP   
0E6C:  NOP   
0E6E:  BTFSS  F82.3
0E70:  BRA    0E6E
0E72:  BCF    F8B.4
0E74:  BCF    F94.4
0E76:  NOP   
0E78:  NOP   
0E7A:  BCF    F8B.3
0E7C:  BCF    F94.3
....................    i2c_write(0xAF);           // Byte de control de lectura. 
0E7E:  MOVLW  AF
0E80:  MOVWF  6A
0E82:  RCALL  0BF0
....................    // Lee donde deberían haberse guardado los flags en la memoria externa 
....................    flag3=i2c_read(1); 
0E84:  MOVLW  01
0E86:  MOVWF  00
0E88:  RCALL  0C4E
0E8A:  MOVFF  01,58
....................    flag4=i2c_read(0); 
0E8E:  CLRF   00
0E90:  RCALL  0C4E
0E92:  MOVFF  01,59
....................    i2c_stop(); 
0E96:  BCF    F94.4
0E98:  NOP   
0E9A:  BSF    F94.3
0E9C:  BTFSS  F82.3
0E9E:  BRA    0E9C
0EA0:  NOP   
0EA2:  NOP   
0EA4:  NOP   
0EA6:  NOP   
0EA8:  NOP   
0EAA:  BSF    F94.4
0EAC:  NOP   
0EAE:  NOP   
....................  
....................    // Comprobamos si encontramos el flag de haber escrito en la eeprom 
....................    if (flag1==0xAB && flag2==0xCD){  // En este caso leo de la memoria interna 
0EB0:  MOVF   56,W
0EB2:  SUBLW  AB
0EB4:  BTFSS  FD8.2
0EB6:  BRA    10CC
0EB8:  MOVF   57,W
0EBA:  SUBLW  CD
0EBC:  BTFSS  FD8.2
0EBE:  BRA    10CC
....................       horaInicio=read_eeprom(0xA0); 
0EC0:  MOVFF  FF2,5A
0EC4:  BCF    FF2.7
0EC6:  MOVLW  A0
0EC8:  MOVWF  FA9
0ECA:  BCF    FA6.6
0ECC:  BCF    FA6.7
0ECE:  BSF    FA6.0
0ED0:  MOVF   FA8,W
0ED2:  BTFSC  5A.7
0ED4:  BSF    FF2.7
0ED6:  MOVWF  2D
....................       minutoInicio=read_eeprom(0xA1); 
0ED8:  MOVFF  FF2,5A
0EDC:  BCF    FF2.7
0EDE:  MOVLW  A1
0EE0:  MOVWF  FA9
0EE2:  BCF    FA6.6
0EE4:  BCF    FA6.7
0EE6:  BSF    FA6.0
0EE8:  MOVF   FA8,W
0EEA:  BTFSC  5A.7
0EEC:  BSF    FF2.7
0EEE:  MOVWF  2E
....................       horaFin=read_eeprom(0xA2); 
0EF0:  MOVFF  FF2,5A
0EF4:  BCF    FF2.7
0EF6:  MOVLW  A2
0EF8:  MOVWF  FA9
0EFA:  BCF    FA6.6
0EFC:  BCF    FA6.7
0EFE:  BSF    FA6.0
0F00:  MOVF   FA8,W
0F02:  BTFSC  5A.7
0F04:  BSF    FF2.7
0F06:  MOVWF  2F
....................       minutoFin=read_eeprom(0xA3); 
0F08:  MOVFF  FF2,5A
0F0C:  BCF    FF2.7
0F0E:  MOVLW  A3
0F10:  MOVWF  FA9
0F12:  BCF    FA6.6
0F14:  BCF    FA6.7
0F16:  BSF    FA6.0
0F18:  MOVF   FA8,W
0F1A:  BTFSC  5A.7
0F1C:  BSF    FF2.7
0F1E:  MOVWF  30
....................       *ptd=read_eeprom(0xA4); 
0F20:  CLRF   03
0F22:  MOVFF  53,FE9
0F26:  MOVFF  03,FEA
0F2A:  MOVFF  FF2,5C
0F2E:  BCF    FF2.7
0F30:  MOVLW  A4
0F32:  MOVWF  FA9
0F34:  BCF    FA6.6
0F36:  BCF    FA6.7
0F38:  BSF    FA6.0
0F3A:  MOVF   FA8,W
0F3C:  BTFSC  5C.7
0F3E:  BSF    FF2.7
0F40:  MOVWF  FEF
....................       *(ptd+1)=read_eeprom(0xA5); 
0F42:  MOVLW  01
0F44:  ADDWF  53,W
0F46:  CLRF   03
0F48:  MOVWF  FE9
0F4A:  MOVFF  03,FEA
0F4E:  MOVFF  FF2,5C
0F52:  BCF    FF2.7
0F54:  MOVLW  A5
0F56:  MOVWF  FA9
0F58:  BCF    FA6.6
0F5A:  BCF    FA6.7
0F5C:  BSF    FA6.0
0F5E:  MOVF   FA8,W
0F60:  BTFSC  5C.7
0F62:  BSF    FF2.7
0F64:  MOVWF  FEF
....................       *(ptd+2)=read_eeprom(0xA6); 
0F66:  MOVLW  02
0F68:  ADDWF  53,W
0F6A:  CLRF   03
0F6C:  MOVWF  FE9
0F6E:  MOVFF  03,FEA
0F72:  MOVFF  FF2,5C
0F76:  BCF    FF2.7
0F78:  MOVLW  A6
0F7A:  MOVWF  FA9
0F7C:  BCF    FA6.6
0F7E:  BCF    FA6.7
0F80:  BSF    FA6.0
0F82:  MOVF   FA8,W
0F84:  BTFSC  5C.7
0F86:  BSF    FF2.7
0F88:  MOVWF  FEF
....................       *(ptd+3)=read_eeprom(0xA7); 
0F8A:  MOVLW  03
0F8C:  ADDWF  53,W
0F8E:  CLRF   03
0F90:  MOVWF  FE9
0F92:  MOVFF  03,FEA
0F96:  MOVFF  FF2,5C
0F9A:  BCF    FF2.7
0F9C:  MOVLW  A7
0F9E:  MOVWF  FA9
0FA0:  BCF    FA6.6
0FA2:  BCF    FA6.7
0FA4:  BSF    FA6.0
0FA6:  MOVF   FA8,W
0FA8:  BTFSC  5C.7
0FAA:  BSF    FF2.7
0FAC:  MOVWF  FEF
....................       *pcd=read_eeprom(0xA8); 
0FAE:  CLRF   03
0FB0:  MOVFF  54,FE9
0FB4:  MOVFF  03,FEA
0FB8:  MOVFF  FF2,5C
0FBC:  BCF    FF2.7
0FBE:  MOVLW  A8
0FC0:  MOVWF  FA9
0FC2:  BCF    FA6.6
0FC4:  BCF    FA6.7
0FC6:  BSF    FA6.0
0FC8:  MOVF   FA8,W
0FCA:  BTFSC  5C.7
0FCC:  BSF    FF2.7
0FCE:  MOVWF  FEF
....................       *(pcd+1)=read_eeprom(0xA9); 
0FD0:  MOVLW  01
0FD2:  ADDWF  54,W
0FD4:  CLRF   03
0FD6:  MOVWF  FE9
0FD8:  MOVFF  03,FEA
0FDC:  MOVFF  FF2,5C
0FE0:  BCF    FF2.7
0FE2:  MOVLW  A9
0FE4:  MOVWF  FA9
0FE6:  BCF    FA6.6
0FE8:  BCF    FA6.7
0FEA:  BSF    FA6.0
0FEC:  MOVF   FA8,W
0FEE:  BTFSC  5C.7
0FF0:  BSF    FF2.7
0FF2:  MOVWF  FEF
....................       *(pcd+2)=read_eeprom(0xAA); 
0FF4:  MOVLW  02
0FF6:  ADDWF  54,W
0FF8:  CLRF   03
0FFA:  MOVWF  FE9
0FFC:  MOVFF  03,FEA
1000:  MOVFF  FF2,5C
1004:  BCF    FF2.7
1006:  MOVLW  AA
1008:  MOVWF  FA9
100A:  BCF    FA6.6
100C:  BCF    FA6.7
100E:  BSF    FA6.0
1010:  MOVF   FA8,W
1012:  BTFSC  5C.7
1014:  BSF    FF2.7
1016:  MOVWF  FEF
....................       *(pcd+3)=read_eeprom(0xAB); 
1018:  MOVLW  03
101A:  ADDWF  54,W
101C:  CLRF   03
101E:  MOVWF  FE9
1020:  MOVFF  03,FEA
1024:  MOVFF  FF2,5C
1028:  BCF    FF2.7
102A:  MOVLW  AB
102C:  MOVWF  FA9
102E:  BCF    FA6.6
1030:  BCF    FA6.7
1032:  BSF    FA6.0
1034:  MOVF   FA8,W
1036:  BTFSC  5C.7
1038:  BSF    FF2.7
103A:  MOVWF  FEF
....................       *ptbd=read_eeprom(0xAC); 
103C:  CLRF   03
103E:  MOVFF  55,FE9
1042:  MOVFF  03,FEA
1046:  MOVFF  FF2,5C
104A:  BCF    FF2.7
104C:  MOVLW  AC
104E:  MOVWF  FA9
1050:  BCF    FA6.6
1052:  BCF    FA6.7
1054:  BSF    FA6.0
1056:  MOVF   FA8,W
1058:  BTFSC  5C.7
105A:  BSF    FF2.7
105C:  MOVWF  FEF
....................       *(ptbd+1)=read_eeprom(0xAD); 
105E:  MOVLW  01
1060:  ADDWF  55,W
1062:  CLRF   03
1064:  MOVWF  FE9
1066:  MOVFF  03,FEA
106A:  MOVFF  FF2,5C
106E:  BCF    FF2.7
1070:  MOVLW  AD
1072:  MOVWF  FA9
1074:  BCF    FA6.6
1076:  BCF    FA6.7
1078:  BSF    FA6.0
107A:  MOVF   FA8,W
107C:  BTFSC  5C.7
107E:  BSF    FF2.7
1080:  MOVWF  FEF
....................       *(ptbd+2)=read_eeprom(0xAE); 
1082:  MOVLW  02
1084:  ADDWF  55,W
1086:  CLRF   03
1088:  MOVWF  FE9
108A:  MOVFF  03,FEA
108E:  MOVFF  FF2,5C
1092:  BCF    FF2.7
1094:  MOVLW  AE
1096:  MOVWF  FA9
1098:  BCF    FA6.6
109A:  BCF    FA6.7
109C:  BSF    FA6.0
109E:  MOVF   FA8,W
10A0:  BTFSC  5C.7
10A2:  BSF    FF2.7
10A4:  MOVWF  FEF
....................       *(ptbd+3)=read_eeprom(0xAF); 
10A6:  MOVLW  03
10A8:  ADDWF  55,W
10AA:  CLRF   03
10AC:  MOVWF  FE9
10AE:  MOVFF  03,FEA
10B2:  MOVFF  FF2,5C
10B6:  BCF    FF2.7
10B8:  MOVLW  AF
10BA:  MOVWF  FA9
10BC:  BCF    FA6.6
10BE:  BCF    FA6.7
10C0:  BSF    FA6.0
10C2:  MOVF   FA8,W
10C4:  BTFSC  5C.7
10C6:  BSF    FF2.7
10C8:  MOVWF  FEF
....................    } 
....................    else if(flag3==0xAB && flag4==0xCD){    // En este otro caso leeré de la memoria I2C externa 
10CA:  BRA    129E
10CC:  MOVF   58,W
10CE:  SUBLW  AB
10D0:  BTFSS  FD8.2
10D2:  BRA    126E
10D4:  MOVF   59,W
10D6:  SUBLW  CD
10D8:  BTFSS  FD8.2
10DA:  BRA    126E
....................       i2c_start(); 
10DC:  BSF    F94.4
10DE:  NOP   
10E0:  NOP   
10E2:  BSF    F94.3
10E4:  NOP   
10E6:  NOP   
10E8:  NOP   
10EA:  BCF    F8B.4
10EC:  BCF    F94.4
10EE:  NOP   
10F0:  NOP   
10F2:  BCF    F8B.3
10F4:  BCF    F94.3
....................       i2c_write(0xAE);     // Byte de control de escritura. 
10F6:  MOVLW  AE
10F8:  MOVWF  6A
10FA:  RCALL  0BF0
....................       i2c_write(0x00);     // 2 bytes de dirección 
10FC:  CLRF   6A
10FE:  RCALL  0BF0
....................       i2c_write(0xA0); 
1100:  MOVLW  A0
1102:  MOVWF  6A
1104:  RCALL  0BF0
....................  
....................       i2c_start(); 
1106:  BSF    F94.4
1108:  NOP   
110A:  NOP   
110C:  BSF    F94.3
110E:  NOP   
1110:  NOP   
1112:  NOP   
1114:  BTFSS  F82.3
1116:  BRA    1114
1118:  BCF    F8B.4
111A:  BCF    F94.4
111C:  NOP   
111E:  NOP   
1120:  BCF    F8B.3
1122:  BCF    F94.3
....................       i2c_write(0xAF);           // Byte de control de lectura. 
1124:  MOVLW  AF
1126:  MOVWF  6A
1128:  RCALL  0BF0
....................       horaInicio=i2c_read(1);    // Con ACK, indicando que hay más datos a leer. 
112A:  MOVLW  01
112C:  MOVWF  00
112E:  RCALL  0C4E
1130:  MOVFF  01,2D
....................       minutoInicio=i2c_read(1); 
1134:  MOVLW  01
1136:  MOVWF  00
1138:  RCALL  0C4E
113A:  MOVFF  01,2E
....................       horaFin=i2c_read(1); 
113E:  MOVLW  01
1140:  MOVWF  00
1142:  RCALL  0C4E
1144:  MOVFF  01,2F
....................       minutoFin=i2c_read(1); 
1148:  MOVLW  01
114A:  MOVWF  00
114C:  RCALL  0C4E
114E:  MOVFF  01,30
....................       *ptd=i2c_read(1); 
1152:  CLRF   03
1154:  MOVFF  53,FE9
1158:  MOVFF  03,FEA
115C:  MOVLW  01
115E:  MOVWF  00
1160:  RCALL  0C4E
1162:  MOVFF  01,FEF
....................       *(ptd+1)=i2c_read(1); 
1166:  MOVLW  01
1168:  ADDWF  53,W
116A:  CLRF   03
116C:  MOVWF  FE9
116E:  MOVFF  03,FEA
1172:  MOVLW  01
1174:  MOVWF  00
1176:  RCALL  0C4E
1178:  MOVFF  01,FEF
....................       *(ptd+2)=i2c_read(1); 
117C:  MOVLW  02
117E:  ADDWF  53,W
1180:  CLRF   03
1182:  MOVWF  FE9
1184:  MOVFF  03,FEA
1188:  MOVLW  01
118A:  MOVWF  00
118C:  RCALL  0C4E
118E:  MOVFF  01,FEF
....................       *(ptd+3)=i2c_read(1); 
1192:  MOVLW  03
1194:  ADDWF  53,W
1196:  CLRF   03
1198:  MOVWF  FE9
119A:  MOVFF  03,FEA
119E:  MOVLW  01
11A0:  MOVWF  00
11A2:  RCALL  0C4E
11A4:  MOVFF  01,FEF
....................       *pcd=i2c_read(1); 
11A8:  CLRF   03
11AA:  MOVFF  54,FE9
11AE:  MOVFF  03,FEA
11B2:  MOVLW  01
11B4:  MOVWF  00
11B6:  RCALL  0C4E
11B8:  MOVFF  01,FEF
....................       *(pcd+1)=i2c_read(1); 
11BC:  MOVLW  01
11BE:  ADDWF  54,W
11C0:  CLRF   03
11C2:  MOVWF  FE9
11C4:  MOVFF  03,FEA
11C8:  MOVLW  01
11CA:  MOVWF  00
11CC:  RCALL  0C4E
11CE:  MOVFF  01,FEF
....................       *(pcd+2)=i2c_read(1); 
11D2:  MOVLW  02
11D4:  ADDWF  54,W
11D6:  CLRF   03
11D8:  MOVWF  FE9
11DA:  MOVFF  03,FEA
11DE:  MOVLW  01
11E0:  MOVWF  00
11E2:  RCALL  0C4E
11E4:  MOVFF  01,FEF
....................       *(pcd+3)=i2c_read(1); 
11E8:  MOVLW  03
11EA:  ADDWF  54,W
11EC:  CLRF   03
11EE:  MOVWF  FE9
11F0:  MOVFF  03,FEA
11F4:  MOVLW  01
11F6:  MOVWF  00
11F8:  RCALL  0C4E
11FA:  MOVFF  01,FEF
....................       *ptbd=i2c_read(1); 
11FE:  CLRF   03
1200:  MOVFF  55,FE9
1204:  MOVFF  03,FEA
1208:  MOVLW  01
120A:  MOVWF  00
120C:  RCALL  0C4E
120E:  MOVFF  01,FEF
....................       *(ptbd+1)=i2c_read(1); 
1212:  MOVLW  01
1214:  ADDWF  55,W
1216:  CLRF   03
1218:  MOVWF  FE9
121A:  MOVFF  03,FEA
121E:  MOVLW  01
1220:  MOVWF  00
1222:  RCALL  0C4E
1224:  MOVFF  01,FEF
....................       *(ptbd+2)=i2c_read(1); 
1228:  MOVLW  02
122A:  ADDWF  55,W
122C:  CLRF   03
122E:  MOVWF  FE9
1230:  MOVFF  03,FEA
1234:  MOVLW  01
1236:  MOVWF  00
1238:  RCALL  0C4E
123A:  MOVFF  01,FEF
....................       *(ptbd+3)=i2c_read(0);     // Último dato a leer. ACK=0. 
123E:  MOVLW  03
1240:  ADDWF  55,W
1242:  CLRF   03
1244:  MOVWF  FE9
1246:  MOVFF  03,FEA
124A:  CLRF   00
124C:  RCALL  0C4E
124E:  MOVFF  01,FEF
....................       i2c_stop(); 
1252:  BCF    F94.4
1254:  NOP   
1256:  BSF    F94.3
1258:  BTFSS  F82.3
125A:  BRA    1258
125C:  NOP   
125E:  NOP   
1260:  NOP   
1262:  NOP   
1264:  NOP   
1266:  BSF    F94.4
1268:  NOP   
126A:  NOP   
....................    } 
....................    else{ 
126C:  BRA    129E
....................       // En otro caso (no se encuentran los flags), cargamos unos valores predeterminados 
....................       horaInicio=19; 
126E:  MOVLW  13
1270:  MOVWF  2D
....................       minutoInicio=30; 
1272:  MOVLW  1E
1274:  MOVWF  2E
....................       horaFin=20; 
1276:  MOVLW  14
1278:  MOVWF  2F
....................       minutoFin=30; 
127A:  MOVLW  1E
127C:  MOVWF  30
....................       tempDeseada=25.0; 
127E:  CLRF   1C
1280:  CLRF   1B
1282:  MOVLW  48
1284:  MOVWF  1A
1286:  MOVLW  83
1288:  MOVWF  19
....................       cloroDeseado=4.0; 
128A:  CLRF   20
128C:  CLRF   1F
128E:  CLRF   1E
1290:  MOVLW  81
1292:  MOVWF  1D
....................       turbidezDeseada=1.0; 
1294:  CLRF   24
1296:  CLRF   23
1298:  CLRF   22
129A:  MOVLW  7F
129C:  MOVWF  21
....................    } 
....................    // Al leer los datos de la memoria EEPROM y haberlos asignados en las variables correspondientes, será de especial interés 
....................    // lo relativo a la hora de encendido y apagado de la depuradora. Comprobamos si está encendida o apagada para introducir 
....................    // en el PCF8583 una hora u otra según esté o no apagada la depuradora. 
....................    if (depuradoraOn==0){ 
129E:  MOVF   33,F
12A0:  BNZ   12B4
....................       // Si no está funcionando, metemos en el PCF la hora de inicio del ciclo. Será lo usual si se supone que leemos en eeprom 
....................       // al inicializar el PIC (depuradora apagada), pero para contemplar posibles cambios en el funcionamiento haremos la 
....................       // comprobación 
....................       dtalarm.hours=horaInicio; 
12A2:  MOVFF  2D,4D
....................       dtalarm.minutes=minutoInicio; 
12A6:  MOVFF  2E,4C
....................       PCF8583_set_alarmtime(&dtalarm); 
12AA:  CLRF   5B
12AC:  MOVLW  4B
12AE:  MOVWF  5A
12B0:  RCALL  0D0E
....................    } 
....................    else{ 
12B2:  BRA    12C4
....................       // En caso de estar activa, se introduce la hora de fin del ciclo 
....................       dtalarm.hours=horaFin; 
12B4:  MOVFF  2F,4D
....................       dtalarm.minutes=minutoFin; 
12B8:  MOVFF  30,4C
....................       PCF8583_set_alarmtime(&dtalarm); 
12BC:  CLRF   5B
12BE:  MOVLW  4B
12C0:  MOVWF  5A
12C2:  RCALL  0D0E
....................    } 
.................... } 
12C4:  RETLW  00
....................  
.................... #include "interfaz.c"         // Todas las funciones relativas a la gestión del menú de usuario 
.................... void menu(){ 
....................    /* 
....................       Una vez haya saltado la interrupción externa correspondiente, se activará un flag que hará que en el bucle de ejecución del programa 
....................       se dé paso a este método. El menú gestionará qué opción está siendo accedida en ese momento según se haya seleccionado con los botones, 
....................       así como el acceso a las distintas opciones (dando paso a otros métodos) cuando así se seleccione. Además, el menú se cerrará completamente 
....................       al pulsar el botón de salida y pondrá a 0 el flag correspondiente. 
....................    */ 
....................    int opcion=0;     // Esta variable determina en qué opción del menú me encuentro 
*
3C78:  CLRF   52
....................  
....................    setup_wdt(WDT_OFF);  // Desactivaremos el perro guardián en el menú para que no reinicie al PIC 
3C7A:  BCF    FD1.0
....................    // Se muestra por el LCD el mensaje correspondiente al menú, y muestra la primera opción 
....................    lcd_send_byte(0,1); 
3C7C:  CLRF   73
3C7E:  MOVLW  01
3C80:  MOVWF  74
3C82:  CALL   0B66
....................    lcd_gotoxy(1,1); 
3C86:  MOVLW  01
3C88:  MOVWF  6F
3C8A:  MOVWF  70
3C8C:  CALL   12C6
....................    lcd_putc("MENU DEL SISTEMA"); 
3C90:  CLRF   53
3C92:  MOVF   53,W
3C94:  CALL   0158
3C98:  IORLW  00
3C9A:  BZ    3CA6
3C9C:  INCF   53,F
3C9E:  MOVWF  6E
3CA0:  CALL   12E8
3CA4:  BRA    3C92
....................    lcd_gotoxy(1,2); 
3CA6:  MOVLW  01
3CA8:  MOVWF  6F
3CAA:  MOVLW  02
3CAC:  MOVWF  70
3CAE:  CALL   12C6
....................    lcd_putc("Depuradora      "); 
3CB2:  CLRF   53
3CB4:  MOVF   53,W
3CB6:  CALL   0184
3CBA:  IORLW  00
3CBC:  BZ    3CC8
3CBE:  INCF   53,F
3CC0:  MOVWF  6E
3CC2:  CALL   12E8
3CC6:  BRA    3CB4
....................    while(!input(PIN_B1));  // Espero hasta que el botón de acceso al menú no esté pulsado 
3CC8:  BSF    F93.1
3CCA:  BTFSS  F81.1
3CCC:  BRA    3CC8
....................    while(1){ 
....................  
....................       if (!input(PIN_E1))  // En caso que se pulse el botón de salida, se sale del bucle 
3CCE:  BSF    F96.1
3CD0:  BTFSC  F84.1
3CD2:  BRA    3CD6
....................          break; 
3CD4:  BRA    3D92
....................  
....................       if (!input(PIN_A4)){ // En caso de que se pulse el botón de siguiente 
3CD6:  BSF    F92.4
3CD8:  BTFSC  F80.4
3CDA:  BRA    3D60
....................          while(!input(PIN_A4));  // Espero hasta que el botón no esté pulsado 
3CDC:  BSF    F92.4
3CDE:  BTFSS  F80.4
3CE0:  BRA    3CDC
....................          opcion++;   // Avanzo a la siguiente opción 
3CE2:  INCF   52,F
....................          lcd_gotoxy(1,2);  // Me voy a la segunda línea del LCD 
3CE4:  MOVLW  01
3CE6:  MOVWF  6F
3CE8:  MOVLW  02
3CEA:  MOVWF  70
3CEC:  CALL   12C6
....................          switch(opcion){ 
3CF0:  MOVLW  01
3CF2:  SUBWF  52,W
3CF4:  ADDLW  FC
3CF6:  BC    3D60
3CF8:  ADDLW  04
3CFA:  GOTO   3DA6
....................             // Muestro un mensaje u otro según la opción que haya seleccionada 
....................             case 1: lcd_putc("Temperatura agua"); 
3CFE:  CLRF   53
3D00:  MOVF   53,W
3D02:  CALL   01B0
3D06:  IORLW  00
3D08:  BZ    3D14
3D0A:  INCF   53,F
3D0C:  MOVWF  6E
3D0E:  CALL   12E8
3D12:  BRA    3D00
....................             break; 
3D14:  BRA    3D60
....................             case 2: lcd_putc("Nivel cloro     "); 
3D16:  CLRF   53
3D18:  MOVF   53,W
3D1A:  CALL   01DC
3D1E:  IORLW  00
3D20:  BZ    3D2C
3D22:  INCF   53,F
3D24:  MOVWF  6E
3D26:  CALL   12E8
3D2A:  BRA    3D18
....................             break; 
3D2C:  BRA    3D60
....................             case 3: lcd_putc("Nivel turbidez  "); 
3D2E:  CLRF   53
3D30:  MOVF   53,W
3D32:  CALL   0208
3D36:  IORLW  00
3D38:  BZ    3D44
3D3A:  INCF   53,F
3D3C:  MOVWF  6E
3D3E:  CALL   12E8
3D42:  BRA    3D30
....................             break; 
3D44:  BRA    3D60
....................             case 4: lcd_putc("Depuradora      "); 
3D46:  CLRF   53
3D48:  MOVF   53,W
3D4A:  CALL   0184
3D4E:  IORLW  00
3D50:  BZ    3D5C
3D52:  INCF   53,F
3D54:  MOVWF  6E
3D56:  CALL   12E8
3D5A:  BRA    3D48
....................             opcion=0; 
3D5C:  CLRF   52
....................             break; 
3D5E:  BRA    3D60
....................          } 
....................       } 
....................  
....................       if (!input(PIN_E0)){    // En caso de que se pulse aceptar 
3D60:  BSF    F96.0
3D62:  BTFSC  F84.0
3D64:  BRA    3D84
....................          while(!input(PIN_E0));  // Espero hasta que el botón no esté pulsado 
3D66:  BSF    F96.0
3D68:  BTFSS  F84.0
3D6A:  BRA    3D66
....................             switch(opcion){ 
3D6C:  MOVF   52,W
3D6E:  ADDLW  FC
3D70:  BC    3D84
3D72:  ADDLW  04
3D74:  GOTO   3DD2
....................                // Se accede a un menú u otro según se haya seleccionado 
....................                case 0: menuAlarma(); 
3D78:  GOTO   2D74
....................                break; 
....................                case 1: menuTemperatura(); 
3D7C:  GOTO   328A
....................                break; 
....................                case 2: menuCloro(); 
3D80:  BRA    35E8
....................                break; 
....................                case 3: menuTurbidez(); 
3D82:  BRA    3930
....................                break; 
....................             } 
....................       } 
....................    comprobar_temperatura(); 
3D84:  CALL   18BA
....................    if (flagDepuradora==1){ 
3D88:  DECFSZ 32,W
3D8A:  BRA    3D90
....................          funcionaDepuradora(); 
3D8C:  CALL   27A0
....................       } 
....................    } 
3D90:  BRA    3CCE
....................    // El flag vuelve a 0 cuando se ha salido del bucle 
....................    flag=0; 
3D92:  CLRF   31
....................    // Se vuelve a activar al perro guardián 
....................    setup_wdt(WDT_ON); 
3D94:  BSF    FD1.0
....................    // Comprueba la temperatura del agua y muestra datos por el LCD justo al salir del menú 
....................    comprobar_temperatura(); 
3D96:  CALL   18BA
....................    mostrar_lcd(); 
3D9A:  CALL   1F04
....................    mostrar_rs232(); 
3D9E:  CALL   23B2
.................... } 
3DA2:  GOTO   400A (RETURN)
....................  
....................  
.................... void menuAlarma(){ 
....................    /* 
....................       En este menú se harán las gestiones relativas a la hora de encendido y apagado de la depuradora, pudiendo consultarse y modificarse. 
....................       Será importante que estos valores modificados se guarden en la EEPROM, y que se guarde en el PCF8583 la alarma correspondiente si es 
....................       la próxima que debería utilizar. Por ejemplo, si la depuradora está apagada y se cambia la hora de inicio, deberá introducirse esta 
....................       hora en el RTC. 
....................    */ 
....................    int inicfin=0;       // Flag para alternar si estamos en la opción de hora de inicio o de fin 
*
2D74:  CLRF   53
....................    int num1,num2,num3,num4;   // Números que se introducirán con el teclado matricial 
....................    int ntp=0;           // Número de teclas pulsadas en el teclado matricial hasta el momento 
2D76:  CLRF   58
....................    lcd_send_byte(0,1); 
2D78:  CLRF   73
2D7A:  MOVLW  01
2D7C:  MOVWF  74
2D7E:  CALL   0B66
....................    lcd_gotoxy(1,1); 
2D82:  MOVLW  01
2D84:  MOVWF  6F
2D86:  MOVWF  70
2D88:  CALL   12C6
....................    // Empieza mostrando la opción de variar la hora de inicio 
....................    printf(lcd_putc,"Hora in.: %u:%u",horaInicio,minutoInicio); 
2D8C:  CLRF   59
2D8E:  MOVF   59,W
2D90:  CALL   0234
2D94:  INCF   59,F
2D96:  MOVWF  00
2D98:  MOVWF  6E
2D9A:  CALL   12E8
2D9E:  MOVLW  0A
2DA0:  SUBWF  59,W
2DA2:  BNZ   2D8E
2DA4:  MOVFF  2D,61
2DA8:  MOVLW  1B
2DAA:  MOVWF  62
2DAC:  CALL   13FE
2DB0:  MOVLW  3A
2DB2:  MOVWF  6E
2DB4:  CALL   12E8
2DB8:  MOVFF  2E,61
2DBC:  MOVLW  1B
2DBE:  MOVWF  62
2DC0:  CALL   13FE
....................    lcd_gotoxy(1,2); 
2DC4:  MOVLW  01
2DC6:  MOVWF  6F
2DC8:  MOVLW  02
2DCA:  MOVWF  70
2DCC:  CALL   12C6
....................    lcd_putc("Modificar?"); 
2DD0:  CLRF   59
2DD2:  MOVF   59,W
2DD4:  CALL   025E
2DD8:  IORLW  00
2DDA:  BZ    2DE6
2DDC:  INCF   59,F
2DDE:  MOVWF  6E
2DE0:  CALL   12E8
2DE4:  BRA    2DD2
....................    while(1){ 
....................       if (!input(PIN_A4)){ // Cuando se pulsa el botón de siguiente 
2DE6:  BSF    F92.4
2DE8:  BTFSC  F80.4
2DEA:  BRA    2ED8
....................          while(!input(PIN_A4)); 
2DEC:  BSF    F92.4
2DEE:  BTFSS  F80.4
2DF0:  BRA    2DEC
....................          // Se muestra un mensaje u otro según estemos en la opción de hora de inicio o de fin 
....................          if (inicfin==0){ 
2DF2:  MOVF   53,F
2DF4:  BNZ   2E68
....................             inicfin=1; 
2DF6:  MOVLW  01
2DF8:  MOVWF  53
....................             lcd_send_byte(0,1); 
2DFA:  CLRF   73
2DFC:  MOVWF  74
2DFE:  CALL   0B66
....................             lcd_gotoxy(1,1); 
2E02:  MOVLW  01
2E04:  MOVWF  6F
2E06:  MOVWF  70
2E08:  CALL   12C6
....................             printf(lcd_putc,"Hora fin: %u:%u",horaFin,minutoFin); 
2E0C:  CLRF   59
2E0E:  MOVF   59,W
2E10:  CALL   0284
2E14:  INCF   59,F
2E16:  MOVWF  00
2E18:  MOVWF  6E
2E1A:  CALL   12E8
2E1E:  MOVLW  0A
2E20:  SUBWF  59,W
2E22:  BNZ   2E0E
2E24:  MOVFF  2F,61
2E28:  MOVLW  1B
2E2A:  MOVWF  62
2E2C:  CALL   13FE
2E30:  MOVLW  3A
2E32:  MOVWF  6E
2E34:  CALL   12E8
2E38:  MOVFF  30,61
2E3C:  MOVLW  1B
2E3E:  MOVWF  62
2E40:  CALL   13FE
....................             lcd_gotoxy(1,2); 
2E44:  MOVLW  01
2E46:  MOVWF  6F
2E48:  MOVLW  02
2E4A:  MOVWF  70
2E4C:  CALL   12C6
....................             lcd_putc("Modificar?"); 
2E50:  CLRF   59
2E52:  MOVF   59,W
2E54:  CALL   025E
2E58:  IORLW  00
2E5A:  BZ    2E66
2E5C:  INCF   59,F
2E5E:  MOVWF  6E
2E60:  CALL   12E8
2E64:  BRA    2E52
....................          } 
....................          else{ 
2E66:  BRA    2ED8
....................             inicfin=0; 
2E68:  CLRF   53
....................             lcd_send_byte(0,1); 
2E6A:  CLRF   73
2E6C:  MOVLW  01
2E6E:  MOVWF  74
2E70:  CALL   0B66
....................             lcd_gotoxy(1,1); 
2E74:  MOVLW  01
2E76:  MOVWF  6F
2E78:  MOVWF  70
2E7A:  CALL   12C6
....................             printf(lcd_putc,"Hora in.: %u:%u",horaInicio,minutoInicio); 
2E7E:  CLRF   59
2E80:  MOVF   59,W
2E82:  CALL   0234
2E86:  INCF   59,F
2E88:  MOVWF  00
2E8A:  MOVWF  6E
2E8C:  CALL   12E8
2E90:  MOVLW  0A
2E92:  SUBWF  59,W
2E94:  BNZ   2E80
2E96:  MOVFF  2D,61
2E9A:  MOVLW  1B
2E9C:  MOVWF  62
2E9E:  CALL   13FE
2EA2:  MOVLW  3A
2EA4:  MOVWF  6E
2EA6:  CALL   12E8
2EAA:  MOVFF  2E,61
2EAE:  MOVLW  1B
2EB0:  MOVWF  62
2EB2:  CALL   13FE
....................             lcd_gotoxy(1,2); 
2EB6:  MOVLW  01
2EB8:  MOVWF  6F
2EBA:  MOVLW  02
2EBC:  MOVWF  70
2EBE:  CALL   12C6
....................             lcd_putc("Modificar?"); 
2EC2:  CLRF   59
2EC4:  MOVF   59,W
2EC6:  CALL   025E
2ECA:  IORLW  00
2ECC:  BZ    2ED8
2ECE:  INCF   59,F
2ED0:  MOVWF  6E
2ED2:  CALL   12E8
2ED6:  BRA    2EC4
....................          } 
....................       } 
....................  
....................       if (!input(PIN_E1)){ // Cuando se pulsa el botón de salir, se vuelve al menú anterior 
2ED8:  BSF    F96.1
2EDA:  BTFSC  F84.1
2EDC:  BRA    2F32
....................          while(!input(PIN_E1)); 
2EDE:  BSF    F96.1
2EE0:  BTFSS  F84.1
2EE2:  BRA    2EDE
....................          lcd_send_byte(0,1); 
2EE4:  CLRF   73
2EE6:  MOVLW  01
2EE8:  MOVWF  74
2EEA:  CALL   0B66
....................          lcd_gotoxy(1,1); 
2EEE:  MOVLW  01
2EF0:  MOVWF  6F
2EF2:  MOVWF  70
2EF4:  CALL   12C6
....................          lcd_putc("MENU DEL SISTEMA"); 
2EF8:  CLRF   59
2EFA:  MOVF   59,W
2EFC:  CALL   0158
2F00:  IORLW  00
2F02:  BZ    2F0E
2F04:  INCF   59,F
2F06:  MOVWF  6E
2F08:  CALL   12E8
2F0C:  BRA    2EFA
....................          lcd_gotoxy(1,2); 
2F0E:  MOVLW  01
2F10:  MOVWF  6F
2F12:  MOVLW  02
2F14:  MOVWF  70
2F16:  CALL   12C6
....................          lcd_putc("Depuradora      "); 
2F1A:  CLRF   59
2F1C:  MOVF   59,W
2F1E:  CALL   0184
2F22:  IORLW  00
2F24:  BZ    2F30
2F26:  INCF   59,F
2F28:  MOVWF  6E
2F2A:  CALL   12E8
2F2E:  BRA    2F1C
....................          break;   // Volverá al bucle de la opción menu() 
2F30:  BRA    325A
....................       } 
....................  
....................       if (!input(PIN_E0) && ntp!=4){ 
2F32:  BSF    F96.0
2F34:  BTFSC  F84.0
2F36:  BRA    3118
2F38:  MOVF   58,W
2F3A:  SUBLW  04
2F3C:  BTFSC  FD8.2
2F3E:  BRA    3118
....................          // Cuando se pulse el botón de aceptar y no se hayan introducido ya los 4 dígitos, mostrará la opción de modificar la hora 
....................          while(!input(PIN_E0)); 
2F40:  BSF    F96.0
2F42:  BTFSS  F84.0
2F44:  BRA    2F40
....................          lcd_send_byte(0,1); 
2F46:  CLRF   73
2F48:  MOVLW  01
2F4A:  MOVWF  74
2F4C:  CALL   0B66
....................          lcd_gotoxy(1,1); 
2F50:  MOVLW  01
2F52:  MOVWF  6F
2F54:  MOVWF  70
2F56:  CALL   12C6
....................          if (inicfin==0)   // Según sea hora de inicio o de fin 
2F5A:  MOVF   53,F
2F5C:  BNZ   2F76
....................             lcd_putc("Nueva hora inic."); 
2F5E:  CLRF   59
2F60:  MOVF   59,W
2F62:  CALL   02AE
2F66:  IORLW  00
2F68:  BZ    2F74
2F6A:  INCF   59,F
2F6C:  MOVWF  6E
2F6E:  CALL   12E8
2F72:  BRA    2F60
....................          else 
2F74:  BRA    2F8C
....................             lcd_putc("Nueva hora fin"); 
2F76:  CLRF   59
2F78:  MOVF   59,W
2F7A:  CALL   02DA
2F7E:  IORLW  00
2F80:  BZ    2F8C
2F82:  INCF   59,F
2F84:  MOVWF  6E
2F86:  CALL   12E8
2F8A:  BRA    2F78
....................          lcd_gotoxy(1,2); 
2F8C:  MOVLW  01
2F8E:  MOVWF  6F
2F90:  MOVLW  02
2F92:  MOVWF  70
2F94:  CALL   12C6
....................          lcd_putc("Formato: XX:XX"); 
2F98:  CLRF   59
2F9A:  MOVF   59,W
2F9C:  CALL   0304
2FA0:  IORLW  00
2FA2:  BZ    2FAE
2FA4:  INCF   59,F
2FA6:  MOVWF  6E
2FA8:  CALL   12E8
2FAC:  BRA    2F9A
....................          lcd_gotoxy(10,2); 
2FAE:  MOVLW  0A
2FB0:  MOVWF  6F
2FB2:  MOVLW  02
2FB4:  MOVWF  70
2FB6:  CALL   12C6
....................          while(ntp<4){ 
2FBA:  MOVF   58,W
2FBC:  SUBLW  03
2FBE:  BTFSS  FD8.0
2FC0:  BRA    3118
....................             // Bucle de ejecución mientras se introducen los números 
....................  
....................             // Si se pulsa el botón de salir, vuelve a la opción anterior 
....................             if (!input(PIN_E1)){ 
2FC2:  BSF    F96.1
2FC4:  BTFSC  F84.1
2FC6:  BRA    307E
....................             while(!input(PIN_E1)); 
2FC8:  BSF    F96.1
2FCA:  BTFSS  F84.1
2FCC:  BRA    2FC8
....................             lcd_send_byte(0,1); 
2FCE:  CLRF   73
2FD0:  MOVLW  01
2FD2:  MOVWF  74
2FD4:  CALL   0B66
....................             lcd_gotoxy(1,1); 
2FD8:  MOVLW  01
2FDA:  MOVWF  6F
2FDC:  MOVWF  70
2FDE:  CALL   12C6
....................             if (inicfin==0) 
2FE2:  MOVF   53,F
2FE4:  BNZ   3020
....................                printf(lcd_putc,"Hora in.: %u:%u",horaInicio,minutoInicio); 
2FE6:  CLRF   59
2FE8:  MOVF   59,W
2FEA:  CALL   0234
2FEE:  INCF   59,F
2FF0:  MOVWF  00
2FF2:  MOVWF  6E
2FF4:  CALL   12E8
2FF8:  MOVLW  0A
2FFA:  SUBWF  59,W
2FFC:  BNZ   2FE8
2FFE:  MOVFF  2D,61
3002:  MOVLW  1B
3004:  MOVWF  62
3006:  CALL   13FE
300A:  MOVLW  3A
300C:  MOVWF  6E
300E:  CALL   12E8
3012:  MOVFF  2E,61
3016:  MOVLW  1B
3018:  MOVWF  62
301A:  CALL   13FE
....................             else 
301E:  BRA    3058
....................                printf(lcd_putc,"Hora fin: %u:%u",horaFin,minutoFin); 
3020:  CLRF   59
3022:  MOVF   59,W
3024:  CALL   0284
3028:  INCF   59,F
302A:  MOVWF  00
302C:  MOVWF  6E
302E:  CALL   12E8
3032:  MOVLW  0A
3034:  SUBWF  59,W
3036:  BNZ   3022
3038:  MOVFF  2F,61
303C:  MOVLW  1B
303E:  MOVWF  62
3040:  CALL   13FE
3044:  MOVLW  3A
3046:  MOVWF  6E
3048:  CALL   12E8
304C:  MOVFF  30,61
3050:  MOVLW  1B
3052:  MOVWF  62
3054:  CALL   13FE
....................             lcd_gotoxy(1,2); 
3058:  MOVLW  01
305A:  MOVWF  6F
305C:  MOVLW  02
305E:  MOVWF  70
3060:  CALL   12C6
....................             lcd_putc("Modificar?"); 
3064:  CLRF   59
3066:  MOVF   59,W
3068:  CALL   025E
306C:  IORLW  00
306E:  BZ    307A
3070:  INCF   59,F
3072:  MOVWF  6E
3074:  CALL   12E8
3078:  BRA    3066
....................             ntp=0; 
307A:  CLRF   58
....................             break; 
307C:  BRA    3118
....................             } 
....................  
....................             // Según las teclas que haya pulsado (iré por un dígito u otro de las horas:minutos) 
....................             switch(ntp){ 
307E:  MOVF   58,W
3080:  ADDLW  FC
3082:  BC    310A
3084:  ADDLW  04
3086:  GOTO   325E
....................                case 0:  num1=kbd_getc(); 
308A:  CALL   132E
308E:  MOVFF  01,54
....................                if (num1<=2){ 
3092:  MOVF   54,W
3094:  SUBLW  02
3096:  BNC   30A6
....................                   printf(lcd_putc,"%u",num1); 
3098:  MOVFF  54,61
309C:  MOVLW  1B
309E:  MOVWF  62
30A0:  CALL   13FE
....................                   ntp++; 
30A4:  INCF   58,F
....................                } 
....................                break; 
30A6:  BRA    310A
....................                case 1:  num2=kbd_getc(); 
30A8:  CALL   132E
30AC:  MOVFF  01,55
....................                if (num2<10){ 
30B0:  MOVF   55,W
30B2:  SUBLW  09
30B4:  BNC   30CC
....................                   printf(lcd_putc,"%u:",num2); 
30B6:  MOVFF  55,61
30BA:  MOVLW  1B
30BC:  MOVWF  62
30BE:  CALL   13FE
30C2:  MOVLW  3A
30C4:  MOVWF  6E
30C6:  CALL   12E8
....................                   ntp++; 
30CA:  INCF   58,F
....................                } 
....................                break; 
30CC:  BRA    310A
....................                case 2:  num3=kbd_getc(); 
30CE:  CALL   132E
30D2:  MOVFF  01,56
....................                if (num3<=5){ 
30D6:  MOVF   56,W
30D8:  SUBLW  05
30DA:  BNC   30EA
....................                   printf(lcd_putc,"%u",num3); 
30DC:  MOVFF  56,61
30E0:  MOVLW  1B
30E2:  MOVWF  62
30E4:  CALL   13FE
....................                   ntp++; 
30E8:  INCF   58,F
....................                } 
....................                break; 
30EA:  BRA    310A
....................                case 3:  num4=kbd_getc(); 
30EC:  CALL   132E
30F0:  MOVFF  01,57
....................                if (num4<10){ 
30F4:  MOVF   57,W
30F6:  SUBLW  09
30F8:  BNC   3108
....................                   printf(lcd_putc,"%u",num4); 
30FA:  MOVFF  57,61
30FE:  MOVLW  1B
3100:  MOVWF  62
3102:  CALL   13FE
....................                   ntp++; 
3106:  INCF   58,F
....................                } 
....................                break; 
3108:  BRA    310A
....................             } 
....................          comprobar_temperatura(); 
310A:  CALL   18BA
....................          if (flagDepuradora==1) 
310E:  DECFSZ 32,W
3110:  BRA    3116
....................             funcionaDepuradora(); 
3112:  CALL   27A0
....................          } 
3116:  BRA    2FBA
....................       } 
....................       // En el caso de que pulse aceptar y ya haya introducido la hora completa 
....................       if (!input(PIN_E0) && ntp==4){ 
3118:  BSF    F96.0
311A:  BTFSC  F84.0
311C:  BRA    324C
311E:  MOVF   58,W
3120:  SUBLW  04
3122:  BTFSS  FD8.2
3124:  BRA    324C
....................          while(!input(PIN_E0)); 
3126:  BSF    F96.0
3128:  BTFSS  F84.0
312A:  BRA    3126
....................          // Compruebo que la hora está entre 0 y 23 
....................          if((10*num1+num2)<24){ 
312C:  MOVF   54,W
312E:  MULLW  0A
3130:  MOVF   FF3,W
3132:  ADDWF  55,W
3134:  SUBLW  17
3136:  BNC   319E
....................             if (inicfin==0){  // Si es la opción de modificar hora de inicio 
3138:  MOVF   53,F
313A:  BNZ   3168
....................                horaInicio=10*num1+num2; 
313C:  MOVF   54,W
313E:  MULLW  0A
3140:  MOVF   FF3,W
3142:  ADDWF  55,W
3144:  MOVWF  2D
....................                minutoInicio=10*num3+num4; // La guardamos en sus variables correspondientes 
3146:  MOVF   56,W
3148:  MULLW  0A
314A:  MOVF   FF3,W
314C:  ADDWF  57,W
314E:  MOVWF  2E
....................                if (depuradoraOn==0){   // Además, si la depuradora está apagada, introduzco esta hora de inicio en el RTC 
3150:  MOVF   33,F
3152:  BNZ   3166
....................                   dtalarm.hours=horaInicio; 
3154:  MOVFF  2D,4D
....................                   dtalarm.minutes=minutoInicio; 
3158:  MOVFF  2E,4C
....................                   PCF8583_set_alarmtime(&dtalarm); 
315C:  CLRF   5B
315E:  MOVLW  4B
3160:  MOVWF  5A
3162:  CALL   0D0E
....................                } 
....................             } 
....................             else{ // Si es la opción de modificar hora de fin 
3166:  BRA    3192
....................                horaFin=10*num1+num2; 
3168:  MOVF   54,W
316A:  MULLW  0A
316C:  MOVF   FF3,W
316E:  ADDWF  55,W
3170:  MOVWF  2F
....................                minutoFin=10*num3+num4; 
3172:  MOVF   56,W
3174:  MULLW  0A
3176:  MOVF   FF3,W
3178:  ADDWF  57,W
317A:  MOVWF  30
....................                if (depuradoraOn==1){   // Esta vez si la depuradora está encendida, introduzco la hora de fin 
317C:  DECFSZ 33,W
317E:  BRA    3192
....................                   dtalarm.hours=horaFin; 
3180:  MOVFF  2F,4D
....................                   dtalarm.minutes=minutoFin; 
3184:  MOVFF  30,4C
....................                   PCF8583_set_alarmtime(&dtalarm); 
3188:  CLRF   5B
318A:  MOVLW  4B
318C:  MOVWF  5A
318E:  CALL   0D0E
....................                } 
....................             } 
....................             delay_ms(10); 
3192:  MOVLW  0A
3194:  MOVWF  75
3196:  CALL   0AFA
....................             escribeEeprom(); 
319A:  CALL   27F2
....................          } 
....................          ntp=0;   // El número de teclas pulsadas vuelve a cero 
319E:  CLRF   58
....................          lcd_send_byte(0,1); 
31A0:  CLRF   73
31A2:  MOVLW  01
31A4:  MOVWF  74
31A6:  CALL   0B66
....................          lcd_gotoxy(1,1); 
31AA:  MOVLW  01
31AC:  MOVWF  6F
31AE:  MOVWF  70
31B0:  CALL   12C6
....................          // Muestro el mensaje anterior de nuevo 
....................          if (inicfin==0) 
31B4:  MOVF   53,F
31B6:  BNZ   31F2
....................             printf(lcd_putc,"Hora in.: %u:%u",horaInicio,minutoInicio); 
31B8:  CLRF   59
31BA:  MOVF   59,W
31BC:  CALL   0234
31C0:  INCF   59,F
31C2:  MOVWF  00
31C4:  MOVWF  6E
31C6:  CALL   12E8
31CA:  MOVLW  0A
31CC:  SUBWF  59,W
31CE:  BNZ   31BA
31D0:  MOVFF  2D,61
31D4:  MOVLW  1B
31D6:  MOVWF  62
31D8:  CALL   13FE
31DC:  MOVLW  3A
31DE:  MOVWF  6E
31E0:  CALL   12E8
31E4:  MOVFF  2E,61
31E8:  MOVLW  1B
31EA:  MOVWF  62
31EC:  CALL   13FE
....................          else 
31F0:  BRA    322A
....................             printf(lcd_putc,"Hora fin: %u:%u",horaFin,minutoFin); 
31F2:  CLRF   59
31F4:  MOVF   59,W
31F6:  CALL   0284
31FA:  INCF   59,F
31FC:  MOVWF  00
31FE:  MOVWF  6E
3200:  CALL   12E8
3204:  MOVLW  0A
3206:  SUBWF  59,W
3208:  BNZ   31F4
320A:  MOVFF  2F,61
320E:  MOVLW  1B
3210:  MOVWF  62
3212:  CALL   13FE
3216:  MOVLW  3A
3218:  MOVWF  6E
321A:  CALL   12E8
321E:  MOVFF  30,61
3222:  MOVLW  1B
3224:  MOVWF  62
3226:  CALL   13FE
....................          lcd_gotoxy(1,2); 
322A:  MOVLW  01
322C:  MOVWF  6F
322E:  MOVLW  02
3230:  MOVWF  70
3232:  CALL   12C6
....................          lcd_putc("Modificar?"); 
3236:  CLRF   59
3238:  MOVF   59,W
323A:  CALL   025E
323E:  IORLW  00
3240:  BZ    324C
3242:  INCF   59,F
3244:  MOVWF  6E
3246:  CALL   12E8
324A:  BRA    3238
....................       } 
....................    comprobar_temperatura(); 
324C:  CALL   18BA
....................    if (flagDepuradora==1) 
3250:  DECFSZ 32,W
3252:  BRA    3258
....................       funcionaDepuradora(); 
3254:  CALL   27A0
....................    } 
3258:  BRA    2DE6
.................... } 
325A:  GOTO   3D84 (RETURN)
....................  
.................... void menuTemperatura(){ 
....................    /* 
....................       En este menú simplemente modificamos la temperatura a la que deseamos que se encuentre el agua en la piscina. Será una variable 
....................       flotante, pero la definiremos con 2 dígitos de parte entera y 1 de parte decimal. 
....................    */ 
....................    int num1,num2,num3;  // Los 3 dígitos del número flotante (parte entera y decimal) 
....................    int ntp=0;  // Número de teclas pulsadas 
*
328A:  CLRF   56
....................    lcd_send_byte(0,1); 
328C:  CLRF   73
328E:  MOVLW  01
3290:  MOVWF  74
3292:  CALL   0B66
....................    lcd_gotoxy(1,1); 
3296:  MOVLW  01
3298:  MOVWF  6F
329A:  MOVWF  70
329C:  CALL   12C6
....................    printf(lcd_putc,"Temp. des.: %2.1f",tempDeseada); 
32A0:  CLRF   57
32A2:  MOVF   57,W
32A4:  CALL   032E
32A8:  INCF   57,F
32AA:  MOVWF  00
32AC:  MOVWF  6E
32AE:  CALL   12E8
32B2:  MOVLW  0C
32B4:  SUBWF  57,W
32B6:  BNZ   32A2
32B8:  MOVLW  01
32BA:  MOVWF  FE9
32BC:  MOVFF  1C,64
32C0:  MOVFF  1B,63
32C4:  MOVFF  1A,62
32C8:  MOVFF  19,61
32CC:  MOVWF  65
32CE:  CALL   1D7E
....................    lcd_gotoxy(1,2); 
32D2:  MOVLW  01
32D4:  MOVWF  6F
32D6:  MOVLW  02
32D8:  MOVWF  70
32DA:  CALL   12C6
....................    lcd_putc("Modificar?"); 
32DE:  CLRF   57
32E0:  MOVF   57,W
32E2:  CALL   025E
32E6:  IORLW  00
32E8:  BZ    32F4
32EA:  INCF   57,F
32EC:  MOVWF  6E
32EE:  CALL   12E8
32F2:  BRA    32E0
....................    while(1){ 
....................       if (!input(PIN_E1)){ // En caso de que se pulse salir, vuelve al menú principal (y lo deja por la opción de temperatura) 
32F4:  BSF    F96.1
32F6:  BTFSC  F84.1
32F8:  BRA    334E
....................          while(!input(PIN_E1)); 
32FA:  BSF    F96.1
32FC:  BTFSS  F84.1
32FE:  BRA    32FA
....................          lcd_send_byte(0,1); 
3300:  CLRF   73
3302:  MOVLW  01
3304:  MOVWF  74
3306:  CALL   0B66
....................          lcd_gotoxy(1,1); 
330A:  MOVLW  01
330C:  MOVWF  6F
330E:  MOVWF  70
3310:  CALL   12C6
....................          lcd_putc("MENU DEL SISTEMA"); 
3314:  CLRF   57
3316:  MOVF   57,W
3318:  CALL   0158
331C:  IORLW  00
331E:  BZ    332A
3320:  INCF   57,F
3322:  MOVWF  6E
3324:  CALL   12E8
3328:  BRA    3316
....................          lcd_gotoxy(1,2); 
332A:  MOVLW  01
332C:  MOVWF  6F
332E:  MOVLW  02
3330:  MOVWF  70
3332:  CALL   12C6
....................          lcd_putc("Temperatura agua"); 
3336:  CLRF   57
3338:  MOVF   57,W
333A:  CALL   01B0
333E:  IORLW  00
3340:  BZ    334C
3342:  INCF   57,F
3344:  MOVWF  6E
3346:  CALL   12E8
334A:  BRA    3338
....................          break; 
334C:  BRA    35E4
....................       } 
....................       // En caso de que se pulse aceptar antes de que se hayan introducido los 3 dígitos 
....................       if (!input(PIN_E0) && ntp!=3){ 
334E:  BSF    F96.0
3350:  BTFSC  F84.0
3352:  BRA    34B8
3354:  MOVF   56,W
3356:  SUBLW  03
3358:  BTFSC  FD8.2
335A:  BRA    34B8
....................          while(!input(PIN_E0)); 
335C:  BSF    F96.0
335E:  BTFSS  F84.0
3360:  BRA    335C
....................          // Se accede a modificar la temperatura 
....................          lcd_send_byte(0,1); 
3362:  CLRF   73
3364:  MOVLW  01
3366:  MOVWF  74
3368:  CALL   0B66
....................          lcd_gotoxy(1,1); 
336C:  MOVLW  01
336E:  MOVWF  6F
3370:  MOVWF  70
3372:  CALL   12C6
....................          lcd_putc("Introduzca temp."); 
3376:  CLRF   57
3378:  MOVF   57,W
337A:  CALL   035A
337E:  IORLW  00
3380:  BZ    338C
3382:  INCF   57,F
3384:  MOVWF  6E
3386:  CALL   12E8
338A:  BRA    3378
....................          lcd_gotoxy(1,2); 
338C:  MOVLW  01
338E:  MOVWF  6F
3390:  MOVLW  02
3392:  MOVWF  70
3394:  CALL   12C6
....................          lcd_putc("Formato: XX.X"); 
3398:  CLRF   57
339A:  MOVF   57,W
339C:  CALL   0386
33A0:  IORLW  00
33A2:  BZ    33AE
33A4:  INCF   57,F
33A6:  MOVWF  6E
33A8:  CALL   12E8
33AC:  BRA    339A
....................          lcd_gotoxy(10,2); 
33AE:  MOVLW  0A
33B0:  MOVWF  6F
33B2:  MOVLW  02
33B4:  MOVWF  70
33B6:  CALL   12C6
....................          while(ntp<3){ 
33BA:  MOVF   56,W
33BC:  SUBLW  02
33BE:  BTFSS  FD8.0
33C0:  BRA    34B8
....................             // Esto se ejecuta mientras no haya introducido la nueva temperatura 
....................             if (!input(PIN_E1)){ 
33C2:  BSF    F96.1
33C4:  BTFSC  F84.1
33C6:  BRA    343A
....................             // En caso de que se pulse salir, volvemos a la opción anterior 
....................             while(!input(PIN_E1)); 
33C8:  BSF    F96.1
33CA:  BTFSS  F84.1
33CC:  BRA    33C8
....................             lcd_send_byte(0,1); 
33CE:  CLRF   73
33D0:  MOVLW  01
33D2:  MOVWF  74
33D4:  CALL   0B66
....................             lcd_gotoxy(1,1); 
33D8:  MOVLW  01
33DA:  MOVWF  6F
33DC:  MOVWF  70
33DE:  CALL   12C6
....................             printf(lcd_putc,"Temp. des.: %2.1f",tempDeseada); 
33E2:  CLRF   57
33E4:  MOVF   57,W
33E6:  CALL   032E
33EA:  INCF   57,F
33EC:  MOVWF  00
33EE:  MOVWF  6E
33F0:  CALL   12E8
33F4:  MOVLW  0C
33F6:  SUBWF  57,W
33F8:  BNZ   33E4
33FA:  MOVLW  01
33FC:  MOVWF  FE9
33FE:  MOVFF  1C,64
3402:  MOVFF  1B,63
3406:  MOVFF  1A,62
340A:  MOVFF  19,61
340E:  MOVWF  65
3410:  CALL   1D7E
....................             lcd_gotoxy(1,2); 
3414:  MOVLW  01
3416:  MOVWF  6F
3418:  MOVLW  02
341A:  MOVWF  70
341C:  CALL   12C6
....................             lcd_putc("Modificar?"); 
3420:  CLRF   57
3422:  MOVF   57,W
3424:  CALL   025E
3428:  IORLW  00
342A:  BZ    3436
342C:  INCF   57,F
342E:  MOVWF  6E
3430:  CALL   12E8
3434:  BRA    3422
....................             ntp=0; 
3436:  CLRF   56
....................             break; 
3438:  BRA    34B8
....................             } 
....................             switch(ntp){ 
343A:  MOVF   56,W
343C:  BZ    3448
343E:  XORLW  01
3440:  BZ    3466
3442:  XORLW  03
3444:  BZ    348C
3446:  BRA    34AA
....................                // Según las teclas pulsadas 
....................                case 0:  num1=kbd_getc(); 
3448:  CALL   132E
344C:  MOVFF  01,53
....................                if (num1<10){ 
3450:  MOVF   53,W
3452:  SUBLW  09
3454:  BNC   3464
....................                   printf(lcd_putc,"%u",num1); 
3456:  MOVFF  53,61
345A:  MOVLW  1B
345C:  MOVWF  62
345E:  CALL   13FE
....................                   ntp++; 
3462:  INCF   56,F
....................                } 
....................                break; 
3464:  BRA    34AA
....................                case 1:  num2=kbd_getc(); 
3466:  CALL   132E
346A:  MOVFF  01,54
....................                if (num2<10){ 
346E:  MOVF   54,W
3470:  SUBLW  09
3472:  BNC   348A
....................                   printf(lcd_putc,"%u.",num2); 
3474:  MOVFF  54,61
3478:  MOVLW  1B
347A:  MOVWF  62
347C:  CALL   13FE
3480:  MOVLW  2E
3482:  MOVWF  6E
3484:  CALL   12E8
....................                   ntp++; 
3488:  INCF   56,F
....................                } 
....................                break; 
348A:  BRA    34AA
....................                case 2:  num3=kbd_getc(); 
348C:  CALL   132E
3490:  MOVFF  01,55
....................                if (num3<10){ 
3494:  MOVF   55,W
3496:  SUBLW  09
3498:  BNC   34A8
....................                   printf(lcd_putc,"%u",num3); 
349A:  MOVFF  55,61
349E:  MOVLW  1B
34A0:  MOVWF  62
34A2:  CALL   13FE
....................                   ntp++; 
34A6:  INCF   56,F
....................                } 
....................                break; 
34A8:  BRA    34AA
....................             } 
....................          comprobar_temperatura(); 
34AA:  CALL   18BA
....................          if (flagDepuradora==1) 
34AE:  DECFSZ 32,W
34B0:  BRA    34B6
....................             funcionaDepuradora(); 
34B2:  CALL   27A0
....................          } 
34B6:  BRA    33BA
....................       } 
....................       if (!input(PIN_E0) && ntp==3){ 
34B8:  BSF    F96.0
34BA:  BTFSC  F84.0
34BC:  BRA    35D6
34BE:  MOVF   56,W
34C0:  SUBLW  03
34C2:  BTFSS  FD8.2
34C4:  BRA    35D6
....................          // Una vez se introduce la temperatura y se pulsa aceptar 
....................          while(!input(PIN_E0)); 
34C6:  BSF    F96.0
34C8:  BTFSS  F84.0
34CA:  BRA    34C6
....................          // Introducimos la temperatura en una variable tipo float 
....................          tempDeseada=10*num1+num2+0.1*num3; 
34CC:  MOVF   53,W
34CE:  MULLW  0A
34D0:  MOVF   FF3,W
34D2:  ADDWF  54,W
34D4:  MOVWF  58
34D6:  CLRF   62
34D8:  MOVFF  55,61
34DC:  CALL   1B98
34E0:  MOVLW  CD
34E2:  MOVWF  71
34E4:  MOVLW  CC
34E6:  MOVWF  70
34E8:  MOVLW  4C
34EA:  MOVWF  6F
34EC:  MOVLW  7B
34EE:  MOVWF  6E
34F0:  MOVFF  03,75
34F4:  MOVFF  02,74
34F8:  MOVFF  01,73
34FC:  MOVFF  00,72
3500:  CALL   1BD0
3504:  MOVFF  00,59
3508:  MOVFF  01,5A
350C:  MOVFF  02,5B
3510:  MOVFF  03,5C
3514:  CLRF   62
3516:  MOVFF  58,61
351A:  CALL   1B98
351E:  BCF    FD8.1
3520:  CLRF   18
3522:  BTFSC  FF2.7
3524:  BSF    18.7
3526:  BCF    FF2.7
3528:  MOVFF  03,7E
352C:  MOVFF  02,7D
3530:  MOVFF  01,7C
3534:  MOVFF  00,7B
3538:  MOVFF  5C,82
353C:  MOVFF  5B,81
3540:  MOVFF  5A,80
3544:  MOVFF  59,7F
3548:  CALL   07B8
354C:  BTFSC  18.7
354E:  BSF    FF2.7
3550:  MOVFF  03,1C
3554:  MOVFF  02,1B
3558:  MOVFF  01,1A
355C:  MOVFF  00,19
....................          delay_ms(10); 
3560:  MOVLW  0A
3562:  MOVWF  75
3564:  CALL   0AFA
....................          escribeEeprom(); 
3568:  CALL   27F2
....................          ntp=0; 
356C:  CLRF   56
....................          lcd_send_byte(0,1); 
356E:  CLRF   73
3570:  MOVLW  01
3572:  MOVWF  74
3574:  CALL   0B66
....................          lcd_gotoxy(1,1); 
3578:  MOVLW  01
357A:  MOVWF  6F
357C:  MOVWF  70
357E:  CALL   12C6
....................          printf(lcd_putc,"Temp. des.: %2.1f",tempDeseada); 
3582:  CLRF   57
3584:  MOVF   57,W
3586:  CALL   032E
358A:  INCF   57,F
358C:  MOVWF  00
358E:  MOVWF  6E
3590:  CALL   12E8
3594:  MOVLW  0C
3596:  SUBWF  57,W
3598:  BNZ   3584
359A:  MOVLW  01
359C:  MOVWF  FE9
359E:  MOVFF  1C,64
35A2:  MOVFF  1B,63
35A6:  MOVFF  1A,62
35AA:  MOVFF  19,61
35AE:  MOVWF  65
35B0:  CALL   1D7E
....................          lcd_gotoxy(1,2); 
35B4:  MOVLW  01
35B6:  MOVWF  6F
35B8:  MOVLW  02
35BA:  MOVWF  70
35BC:  CALL   12C6
....................          lcd_putc("Modificar?"); 
35C0:  CLRF   57
35C2:  MOVF   57,W
35C4:  CALL   025E
35C8:  IORLW  00
35CA:  BZ    35D6
35CC:  INCF   57,F
35CE:  MOVWF  6E
35D0:  CALL   12E8
35D4:  BRA    35C2
....................       } 
....................    comprobar_temperatura(); 
35D6:  CALL   18BA
....................    if (flagDepuradora==1) 
35DA:  DECFSZ 32,W
35DC:  BRA    35E2
....................       funcionaDepuradora(); 
35DE:  CALL   27A0
....................    } 
35E2:  BRA    32F4
.................... } 
35E4:  GOTO   3D84 (RETURN)
....................  
.................... void menuCloro(){ 
....................    /* 
....................       El funcionamiento de este menú será idéntico al definido para la temperatura, pero únicamente con un dígito entero y otro decimal 
....................    */ 
....................    int num1,num2; 
....................    int ntp=0; 
35E8:  CLRF   55
....................    lcd_send_byte(0,1); 
35EA:  CLRF   73
35EC:  MOVLW  01
35EE:  MOVWF  74
35F0:  CALL   0B66
....................    lcd_gotoxy(1,1); 
35F4:  MOVLW  01
35F6:  MOVWF  6F
35F8:  MOVWF  70
35FA:  CALL   12C6
....................    printf(lcd_putc,"Cloro. des.: %1.1f",cloroDeseado); 
35FE:  CLRF   56
3600:  MOVF   56,W
3602:  CALL   03AE
3606:  INCF   56,F
3608:  MOVWF  00
360A:  MOVWF  6E
360C:  CALL   12E8
3610:  MOVLW  0D
3612:  SUBWF  56,W
3614:  BNZ   3600
3616:  MOVLW  89
3618:  MOVWF  FE9
361A:  MOVFF  20,64
361E:  MOVFF  1F,63
3622:  MOVFF  1E,62
3626:  MOVFF  1D,61
362A:  MOVLW  01
362C:  MOVWF  65
362E:  CALL   1D7E
....................    lcd_gotoxy(1,2); 
3632:  MOVLW  01
3634:  MOVWF  6F
3636:  MOVLW  02
3638:  MOVWF  70
363A:  CALL   12C6
....................    lcd_putc("Modificar?"); 
363E:  CLRF   56
3640:  MOVF   56,W
3642:  CALL   025E
3646:  IORLW  00
3648:  BZ    3654
364A:  INCF   56,F
364C:  MOVWF  6E
364E:  CALL   12E8
3652:  BRA    3640
....................    while(1){ 
....................       if (!input(PIN_E1)){ 
3654:  BSF    F96.1
3656:  BTFSC  F84.1
3658:  BRA    36AE
....................          while(!input(PIN_E1)); 
365A:  BSF    F96.1
365C:  BTFSS  F84.1
365E:  BRA    365A
....................          lcd_send_byte(0,1); 
3660:  CLRF   73
3662:  MOVLW  01
3664:  MOVWF  74
3666:  CALL   0B66
....................          lcd_gotoxy(1,1); 
366A:  MOVLW  01
366C:  MOVWF  6F
366E:  MOVWF  70
3670:  CALL   12C6
....................          lcd_putc("MENU DEL SISTEMA"); 
3674:  CLRF   56
3676:  MOVF   56,W
3678:  CALL   0158
367C:  IORLW  00
367E:  BZ    368A
3680:  INCF   56,F
3682:  MOVWF  6E
3684:  CALL   12E8
3688:  BRA    3676
....................          lcd_gotoxy(1,2); 
368A:  MOVLW  01
368C:  MOVWF  6F
368E:  MOVLW  02
3690:  MOVWF  70
3692:  CALL   12C6
....................          lcd_putc("Nivel cloro     "); 
3696:  CLRF   56
3698:  MOVF   56,W
369A:  CALL   01DC
369E:  IORLW  00
36A0:  BZ    36AC
36A2:  INCF   56,F
36A4:  MOVWF  6E
36A6:  CALL   12E8
36AA:  BRA    3698
....................          break; 
36AC:  BRA    392C
....................       } 
....................  
....................       if (!input(PIN_E0) && ntp!=2){ 
36AE:  BSF    F96.0
36B0:  BTFSC  F84.0
36B2:  BRA    37F8
36B4:  MOVF   55,W
36B6:  SUBLW  02
36B8:  BTFSC  FD8.2
36BA:  BRA    37F8
....................          while(!input(PIN_E0)); 
36BC:  BSF    F96.0
36BE:  BTFSS  F84.0
36C0:  BRA    36BC
....................          lcd_send_byte(0,1); 
36C2:  CLRF   73
36C4:  MOVLW  01
36C6:  MOVWF  74
36C8:  CALL   0B66
....................          lcd_gotoxy(1,1); 
36CC:  MOVLW  01
36CE:  MOVWF  6F
36D0:  MOVWF  70
36D2:  CALL   12C6
....................          lcd_putc("Nuevo nv. cloro"); 
36D6:  CLRF   56
36D8:  MOVF   56,W
36DA:  CALL   03DC
36DE:  IORLW  00
36E0:  BZ    36EC
36E2:  INCF   56,F
36E4:  MOVWF  6E
36E6:  CALL   12E8
36EA:  BRA    36D8
....................          lcd_gotoxy(1,2); 
36EC:  MOVLW  01
36EE:  MOVWF  6F
36F0:  MOVLW  02
36F2:  MOVWF  70
36F4:  CALL   12C6
....................          lcd_putc("Formato: X.X"); 
36F8:  CLRF   56
36FA:  MOVF   56,W
36FC:  CALL   0406
3700:  IORLW  00
3702:  BZ    370E
3704:  INCF   56,F
3706:  MOVWF  6E
3708:  CALL   12E8
370C:  BRA    36FA
....................          lcd_gotoxy(10,2); 
370E:  MOVLW  0A
3710:  MOVWF  6F
3712:  MOVLW  02
3714:  MOVWF  70
3716:  CALL   12C6
....................          while(ntp<2){ 
371A:  MOVF   55,W
371C:  SUBLW  01
371E:  BTFSS  FD8.0
3720:  BRA    37F8
....................             if (!input(PIN_E1)){ 
3722:  BSF    F96.1
3724:  BTFSC  F84.1
3726:  BRA    379C
....................             while(!input(PIN_E1)); 
3728:  BSF    F96.1
372A:  BTFSS  F84.1
372C:  BRA    3728
....................             lcd_send_byte(0,1); 
372E:  CLRF   73
3730:  MOVLW  01
3732:  MOVWF  74
3734:  CALL   0B66
....................             lcd_gotoxy(1,1); 
3738:  MOVLW  01
373A:  MOVWF  6F
373C:  MOVWF  70
373E:  CALL   12C6
....................             printf(lcd_putc,"Cloro. des.: %1.1f",cloroDeseado); 
3742:  CLRF   56
3744:  MOVF   56,W
3746:  CALL   03AE
374A:  INCF   56,F
374C:  MOVWF  00
374E:  MOVWF  6E
3750:  CALL   12E8
3754:  MOVLW  0D
3756:  SUBWF  56,W
3758:  BNZ   3744
375A:  MOVLW  89
375C:  MOVWF  FE9
375E:  MOVFF  20,64
3762:  MOVFF  1F,63
3766:  MOVFF  1E,62
376A:  MOVFF  1D,61
376E:  MOVLW  01
3770:  MOVWF  65
3772:  CALL   1D7E
....................             lcd_gotoxy(1,2); 
3776:  MOVLW  01
3778:  MOVWF  6F
377A:  MOVLW  02
377C:  MOVWF  70
377E:  CALL   12C6
....................             lcd_putc("Modificar?"); 
3782:  CLRF   56
3784:  MOVF   56,W
3786:  CALL   025E
378A:  IORLW  00
378C:  BZ    3798
378E:  INCF   56,F
3790:  MOVWF  6E
3792:  CALL   12E8
3796:  BRA    3784
....................             ntp=0; 
3798:  CLRF   55
....................             break; 
379A:  BRA    37F8
....................             } 
....................             switch(ntp){ 
379C:  MOVF   55,W
379E:  BZ    37A6
37A0:  XORLW  01
37A2:  BZ    37CC
37A4:  BRA    37EA
....................                case 0:  num1=kbd_getc(); 
37A6:  CALL   132E
37AA:  MOVFF  01,53
....................                if (num1<10){ 
37AE:  MOVF   53,W
37B0:  SUBLW  09
37B2:  BNC   37CA
....................                   printf(lcd_putc,"%u.",num1); 
37B4:  MOVFF  53,61
37B8:  MOVLW  1B
37BA:  MOVWF  62
37BC:  CALL   13FE
37C0:  MOVLW  2E
37C2:  MOVWF  6E
37C4:  CALL   12E8
....................                   ntp++; 
37C8:  INCF   55,F
....................                } 
....................                break; 
37CA:  BRA    37EA
....................                case 1:  num2=kbd_getc(); 
37CC:  CALL   132E
37D0:  MOVFF  01,54
....................                if (num2<10){ 
37D4:  MOVF   54,W
37D6:  SUBLW  09
37D8:  BNC   37E8
....................                   printf(lcd_putc,"%u",num2); 
37DA:  MOVFF  54,61
37DE:  MOVLW  1B
37E0:  MOVWF  62
37E2:  CALL   13FE
....................                   ntp++; 
37E6:  INCF   55,F
....................                } 
....................                break; 
37E8:  BRA    37EA
....................             } 
....................          comprobar_temperatura(); 
37EA:  CALL   18BA
....................          if (flagDepuradora==1) 
37EE:  DECFSZ 32,W
37F0:  BRA    37F6
....................             funcionaDepuradora(); 
37F2:  CALL   27A0
....................          } 
37F6:  BRA    371A
....................       } 
....................       if (!input(PIN_E0) && ntp==2){ 
37F8:  BSF    F96.0
37FA:  BTFSC  F84.0
37FC:  BRA    391E
37FE:  MOVF   55,W
3800:  SUBLW  02
3802:  BTFSS  FD8.2
3804:  BRA    391E
....................          while(!input(PIN_E0)); 
3806:  BSF    F96.0
3808:  BTFSS  F84.0
380A:  BRA    3806
....................          if(num1<5 || (num1==5 && num2==0)){ 
380C:  MOVF   53,W
380E:  SUBLW  04
3810:  BC    381C
3812:  MOVF   53,W
3814:  SUBLW  05
3816:  BNZ   38B2
3818:  MOVF   54,F
381A:  BNZ   38B2
....................             cloroDeseado=num1+0.1*num2; 
381C:  CLRF   62
381E:  MOVFF  54,61
3822:  CALL   1B98
3826:  MOVLW  CD
3828:  MOVWF  71
382A:  MOVLW  CC
382C:  MOVWF  70
382E:  MOVLW  4C
3830:  MOVWF  6F
3832:  MOVLW  7B
3834:  MOVWF  6E
3836:  MOVFF  03,75
383A:  MOVFF  02,74
383E:  MOVFF  01,73
3842:  MOVFF  00,72
3846:  CALL   1BD0
384A:  MOVFF  00,56
384E:  MOVFF  01,57
3852:  MOVFF  02,58
3856:  MOVFF  03,59
385A:  CLRF   62
385C:  MOVFF  53,61
3860:  CALL   1B98
3864:  BCF    FD8.1
3866:  CLRF   18
3868:  BTFSC  FF2.7
386A:  BSF    18.7
386C:  BCF    FF2.7
386E:  MOVFF  03,7E
3872:  MOVFF  02,7D
3876:  MOVFF  01,7C
387A:  MOVFF  00,7B
387E:  MOVFF  59,82
3882:  MOVFF  58,81
3886:  MOVFF  57,80
388A:  MOVFF  56,7F
388E:  CALL   07B8
3892:  BTFSC  18.7
3894:  BSF    FF2.7
3896:  MOVFF  03,20
389A:  MOVFF  02,1F
389E:  MOVFF  01,1E
38A2:  MOVFF  00,1D
....................             delay_ms(10); 
38A6:  MOVLW  0A
38A8:  MOVWF  75
38AA:  CALL   0AFA
....................             escribeEeprom(); 
38AE:  CALL   27F2
....................          } 
....................          ntp=0; 
38B2:  CLRF   55
....................          lcd_send_byte(0,1); 
38B4:  CLRF   73
38B6:  MOVLW  01
38B8:  MOVWF  74
38BA:  CALL   0B66
....................          lcd_gotoxy(1,1); 
38BE:  MOVLW  01
38C0:  MOVWF  6F
38C2:  MOVWF  70
38C4:  CALL   12C6
....................          printf(lcd_putc,"Cloro. des.: %1.1f",cloroDeseado); 
38C8:  CLRF   56
38CA:  MOVF   56,W
38CC:  CALL   03AE
38D0:  INCF   56,F
38D2:  MOVWF  00
38D4:  MOVWF  6E
38D6:  CALL   12E8
38DA:  MOVLW  0D
38DC:  SUBWF  56,W
38DE:  BNZ   38CA
38E0:  MOVLW  89
38E2:  MOVWF  FE9
38E4:  MOVFF  20,64
38E8:  MOVFF  1F,63
38EC:  MOVFF  1E,62
38F0:  MOVFF  1D,61
38F4:  MOVLW  01
38F6:  MOVWF  65
38F8:  CALL   1D7E
....................          lcd_gotoxy(1,2); 
38FC:  MOVLW  01
38FE:  MOVWF  6F
3900:  MOVLW  02
3902:  MOVWF  70
3904:  CALL   12C6
....................          lcd_putc("Modificar?"); 
3908:  CLRF   56
390A:  MOVF   56,W
390C:  CALL   025E
3910:  IORLW  00
3912:  BZ    391E
3914:  INCF   56,F
3916:  MOVWF  6E
3918:  CALL   12E8
391C:  BRA    390A
....................       } 
....................    comprobar_temperatura(); 
391E:  CALL   18BA
....................    if (flagDepuradora==1) 
3922:  DECFSZ 32,W
3924:  BRA    392A
....................       funcionaDepuradora(); 
3926:  CALL   27A0
....................    } 
392A:  BRA    3654
.................... } 
392C:  GOTO   3D84 (RETURN)
....................  
.................... void menuTurbidez(){ 
....................    /* 
....................       Este menú es idéntico al de modificar el nivel de cloro 
....................    */ 
....................    int num1,num2; 
....................    int ntp=0; 
3930:  CLRF   55
....................    lcd_send_byte(0,1); 
3932:  CLRF   73
3934:  MOVLW  01
3936:  MOVWF  74
3938:  CALL   0B66
....................    lcd_gotoxy(1,1); 
393C:  MOVLW  01
393E:  MOVWF  6F
3940:  MOVWF  70
3942:  CALL   12C6
....................    printf(lcd_putc,"Turbi. des.: %1.1f",turbidezDeseada); 
3946:  CLRF   56
3948:  MOVF   56,W
394A:  CALL   042E
394E:  INCF   56,F
3950:  MOVWF  00
3952:  MOVWF  6E
3954:  CALL   12E8
3958:  MOVLW  0D
395A:  SUBWF  56,W
395C:  BNZ   3948
395E:  MOVLW  89
3960:  MOVWF  FE9
3962:  MOVFF  24,64
3966:  MOVFF  23,63
396A:  MOVFF  22,62
396E:  MOVFF  21,61
3972:  MOVLW  01
3974:  MOVWF  65
3976:  CALL   1D7E
....................    lcd_gotoxy(1,2); 
397A:  MOVLW  01
397C:  MOVWF  6F
397E:  MOVLW  02
3980:  MOVWF  70
3982:  CALL   12C6
....................    lcd_putc("Modificar?"); 
3986:  CLRF   56
3988:  MOVF   56,W
398A:  CALL   025E
398E:  IORLW  00
3990:  BZ    399C
3992:  INCF   56,F
3994:  MOVWF  6E
3996:  CALL   12E8
399A:  BRA    3988
....................    while(1){ 
....................       if (!input(PIN_E1)){ 
399C:  BSF    F96.1
399E:  BTFSC  F84.1
39A0:  BRA    39F6
....................          while(!input(PIN_E1)); 
39A2:  BSF    F96.1
39A4:  BTFSS  F84.1
39A6:  BRA    39A2
....................          lcd_send_byte(0,1); 
39A8:  CLRF   73
39AA:  MOVLW  01
39AC:  MOVWF  74
39AE:  CALL   0B66
....................          lcd_gotoxy(1,1); 
39B2:  MOVLW  01
39B4:  MOVWF  6F
39B6:  MOVWF  70
39B8:  CALL   12C6
....................          lcd_putc("MENU DEL SISTEMA"); 
39BC:  CLRF   56
39BE:  MOVF   56,W
39C0:  CALL   0158
39C4:  IORLW  00
39C6:  BZ    39D2
39C8:  INCF   56,F
39CA:  MOVWF  6E
39CC:  CALL   12E8
39D0:  BRA    39BE
....................          lcd_gotoxy(1,2); 
39D2:  MOVLW  01
39D4:  MOVWF  6F
39D6:  MOVLW  02
39D8:  MOVWF  70
39DA:  CALL   12C6
....................          lcd_putc("Nivel turbidez  "); 
39DE:  CLRF   56
39E0:  MOVF   56,W
39E2:  CALL   0208
39E6:  IORLW  00
39E8:  BZ    39F4
39EA:  INCF   56,F
39EC:  MOVWF  6E
39EE:  CALL   12E8
39F2:  BRA    39E0
....................          break; 
39F4:  BRA    3C74
....................       } 
....................  
....................       if (!input(PIN_E0) && ntp!=2){ 
39F6:  BSF    F96.0
39F8:  BTFSC  F84.0
39FA:  BRA    3B40
39FC:  MOVF   55,W
39FE:  SUBLW  02
3A00:  BTFSC  FD8.2
3A02:  BRA    3B40
....................          while(!input(PIN_E0)); 
3A04:  BSF    F96.0
3A06:  BTFSS  F84.0
3A08:  BRA    3A04
....................          lcd_send_byte(0,1); 
3A0A:  CLRF   73
3A0C:  MOVLW  01
3A0E:  MOVWF  74
3A10:  CALL   0B66
....................          lcd_gotoxy(1,1); 
3A14:  MOVLW  01
3A16:  MOVWF  6F
3A18:  MOVWF  70
3A1A:  CALL   12C6
....................          lcd_putc("Nuevo nv. turb."); 
3A1E:  CLRF   56
3A20:  MOVF   56,W
3A22:  CALL   045C
3A26:  IORLW  00
3A28:  BZ    3A34
3A2A:  INCF   56,F
3A2C:  MOVWF  6E
3A2E:  CALL   12E8
3A32:  BRA    3A20
....................          lcd_gotoxy(1,2); 
3A34:  MOVLW  01
3A36:  MOVWF  6F
3A38:  MOVLW  02
3A3A:  MOVWF  70
3A3C:  CALL   12C6
....................          lcd_putc("Formato: X.X"); 
3A40:  CLRF   56
3A42:  MOVF   56,W
3A44:  CALL   0406
3A48:  IORLW  00
3A4A:  BZ    3A56
3A4C:  INCF   56,F
3A4E:  MOVWF  6E
3A50:  CALL   12E8
3A54:  BRA    3A42
....................          lcd_gotoxy(10,2); 
3A56:  MOVLW  0A
3A58:  MOVWF  6F
3A5A:  MOVLW  02
3A5C:  MOVWF  70
3A5E:  CALL   12C6
....................          while(ntp<2){ 
3A62:  MOVF   55,W
3A64:  SUBLW  01
3A66:  BTFSS  FD8.0
3A68:  BRA    3B40
....................             if (!input(PIN_E1)){ 
3A6A:  BSF    F96.1
3A6C:  BTFSC  F84.1
3A6E:  BRA    3AE4
....................             while(!input(PIN_E1)); 
3A70:  BSF    F96.1
3A72:  BTFSS  F84.1
3A74:  BRA    3A70
....................             lcd_send_byte(0,1); 
3A76:  CLRF   73
3A78:  MOVLW  01
3A7A:  MOVWF  74
3A7C:  CALL   0B66
....................             lcd_gotoxy(1,1); 
3A80:  MOVLW  01
3A82:  MOVWF  6F
3A84:  MOVWF  70
3A86:  CALL   12C6
....................             printf(lcd_putc,"Turbi. des.: %1.1f",turbidezDeseada); 
3A8A:  CLRF   56
3A8C:  MOVF   56,W
3A8E:  CALL   042E
3A92:  INCF   56,F
3A94:  MOVWF  00
3A96:  MOVWF  6E
3A98:  CALL   12E8
3A9C:  MOVLW  0D
3A9E:  SUBWF  56,W
3AA0:  BNZ   3A8C
3AA2:  MOVLW  89
3AA4:  MOVWF  FE9
3AA6:  MOVFF  24,64
3AAA:  MOVFF  23,63
3AAE:  MOVFF  22,62
3AB2:  MOVFF  21,61
3AB6:  MOVLW  01
3AB8:  MOVWF  65
3ABA:  CALL   1D7E
....................             lcd_gotoxy(1,2); 
3ABE:  MOVLW  01
3AC0:  MOVWF  6F
3AC2:  MOVLW  02
3AC4:  MOVWF  70
3AC6:  CALL   12C6
....................             lcd_putc("Modificar?"); 
3ACA:  CLRF   56
3ACC:  MOVF   56,W
3ACE:  CALL   025E
3AD2:  IORLW  00
3AD4:  BZ    3AE0
3AD6:  INCF   56,F
3AD8:  MOVWF  6E
3ADA:  CALL   12E8
3ADE:  BRA    3ACC
....................             ntp=0; 
3AE0:  CLRF   55
....................             break; 
3AE2:  BRA    3B40
....................             } 
....................             switch(ntp){ 
3AE4:  MOVF   55,W
3AE6:  BZ    3AEE
3AE8:  XORLW  01
3AEA:  BZ    3B14
3AEC:  BRA    3B32
....................                case 0:  num1=kbd_getc(); 
3AEE:  CALL   132E
3AF2:  MOVFF  01,53
....................                if (num1<10){ 
3AF6:  MOVF   53,W
3AF8:  SUBLW  09
3AFA:  BNC   3B12
....................                   printf(lcd_putc,"%u.",num1); 
3AFC:  MOVFF  53,61
3B00:  MOVLW  1B
3B02:  MOVWF  62
3B04:  CALL   13FE
3B08:  MOVLW  2E
3B0A:  MOVWF  6E
3B0C:  CALL   12E8
....................                   ntp++; 
3B10:  INCF   55,F
....................                } 
....................                break; 
3B12:  BRA    3B32
....................                case 1:  num2=kbd_getc(); 
3B14:  CALL   132E
3B18:  MOVFF  01,54
....................                if (num2<10){ 
3B1C:  MOVF   54,W
3B1E:  SUBLW  09
3B20:  BNC   3B30
....................                   printf(lcd_putc,"%u",num2); 
3B22:  MOVFF  54,61
3B26:  MOVLW  1B
3B28:  MOVWF  62
3B2A:  CALL   13FE
....................                   ntp++; 
3B2E:  INCF   55,F
....................                } 
....................                break; 
3B30:  BRA    3B32
....................             } 
....................          comprobar_temperatura(); 
3B32:  CALL   18BA
....................          if (flagDepuradora==1) 
3B36:  DECFSZ 32,W
3B38:  BRA    3B3E
....................             funcionaDepuradora(); 
3B3A:  CALL   27A0
....................          } 
3B3E:  BRA    3A62
....................       } 
....................       if (!input(PIN_E0) && ntp==2){ 
3B40:  BSF    F96.0
3B42:  BTFSC  F84.0
3B44:  BRA    3C66
3B46:  MOVF   55,W
3B48:  SUBLW  02
3B4A:  BTFSS  FD8.2
3B4C:  BRA    3C66
....................          while(!input(PIN_E0)); 
3B4E:  BSF    F96.0
3B50:  BTFSS  F84.0
3B52:  BRA    3B4E
....................          if(num1<5 || (num1==5 && num2==0)){ 
3B54:  MOVF   53,W
3B56:  SUBLW  04
3B58:  BC    3B64
3B5A:  MOVF   53,W
3B5C:  SUBLW  05
3B5E:  BNZ   3BFA
3B60:  MOVF   54,F
3B62:  BNZ   3BFA
....................             turbidezDeseada=num1+0.1*num2; 
3B64:  CLRF   62
3B66:  MOVFF  54,61
3B6A:  CALL   1B98
3B6E:  MOVLW  CD
3B70:  MOVWF  71
3B72:  MOVLW  CC
3B74:  MOVWF  70
3B76:  MOVLW  4C
3B78:  MOVWF  6F
3B7A:  MOVLW  7B
3B7C:  MOVWF  6E
3B7E:  MOVFF  03,75
3B82:  MOVFF  02,74
3B86:  MOVFF  01,73
3B8A:  MOVFF  00,72
3B8E:  CALL   1BD0
3B92:  MOVFF  00,56
3B96:  MOVFF  01,57
3B9A:  MOVFF  02,58
3B9E:  MOVFF  03,59
3BA2:  CLRF   62
3BA4:  MOVFF  53,61
3BA8:  CALL   1B98
3BAC:  BCF    FD8.1
3BAE:  CLRF   18
3BB0:  BTFSC  FF2.7
3BB2:  BSF    18.7
3BB4:  BCF    FF2.7
3BB6:  MOVFF  03,7E
3BBA:  MOVFF  02,7D
3BBE:  MOVFF  01,7C
3BC2:  MOVFF  00,7B
3BC6:  MOVFF  59,82
3BCA:  MOVFF  58,81
3BCE:  MOVFF  57,80
3BD2:  MOVFF  56,7F
3BD6:  CALL   07B8
3BDA:  BTFSC  18.7
3BDC:  BSF    FF2.7
3BDE:  MOVFF  03,24
3BE2:  MOVFF  02,23
3BE6:  MOVFF  01,22
3BEA:  MOVFF  00,21
....................             delay_ms(10); 
3BEE:  MOVLW  0A
3BF0:  MOVWF  75
3BF2:  CALL   0AFA
....................             escribeEeprom(); 
3BF6:  CALL   27F2
....................          } 
....................          ntp=0; 
3BFA:  CLRF   55
....................          lcd_send_byte(0,1); 
3BFC:  CLRF   73
3BFE:  MOVLW  01
3C00:  MOVWF  74
3C02:  CALL   0B66
....................          lcd_gotoxy(1,1); 
3C06:  MOVLW  01
3C08:  MOVWF  6F
3C0A:  MOVWF  70
3C0C:  CALL   12C6
....................          printf(lcd_putc,"Turbi. des.: %1.1f",turbidezDeseada); 
3C10:  CLRF   56
3C12:  MOVF   56,W
3C14:  CALL   042E
3C18:  INCF   56,F
3C1A:  MOVWF  00
3C1C:  MOVWF  6E
3C1E:  CALL   12E8
3C22:  MOVLW  0D
3C24:  SUBWF  56,W
3C26:  BNZ   3C12
3C28:  MOVLW  89
3C2A:  MOVWF  FE9
3C2C:  MOVFF  24,64
3C30:  MOVFF  23,63
3C34:  MOVFF  22,62
3C38:  MOVFF  21,61
3C3C:  MOVLW  01
3C3E:  MOVWF  65
3C40:  CALL   1D7E
....................          lcd_gotoxy(1,2); 
3C44:  MOVLW  01
3C46:  MOVWF  6F
3C48:  MOVLW  02
3C4A:  MOVWF  70
3C4C:  CALL   12C6
....................          lcd_putc("Modificar?"); 
3C50:  CLRF   56
3C52:  MOVF   56,W
3C54:  CALL   025E
3C58:  IORLW  00
3C5A:  BZ    3C66
3C5C:  INCF   56,F
3C5E:  MOVWF  6E
3C60:  CALL   12E8
3C64:  BRA    3C52
....................       } 
....................    comprobar_temperatura(); 
3C66:  CALL   18BA
....................    if (flagDepuradora==1) 
3C6A:  DECFSZ 32,W
3C6C:  BRA    3C72
....................       funcionaDepuradora(); 
3C6E:  CALL   27A0
....................    } 
3C72:  BRA    399C
.................... } 
3C74:  GOTO   3D84 (RETURN)
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
....................  
....................  
.................... #int_TIMER1 
.................... void manejo_timer1(){ 
....................    /* 
....................       El timer 1 está configurado para trabajar con un prescaler de 8, y le asignamos 15536 cuentas de inicio, por lo que se desbordará 
....................       cada 0.2 segundos, el tiempo equivalente a dosificar un valor de 0.1 voltios en cloro o floculante. Esto se hace así porque los 
....................       niveles deseados de cloro y turbidez solo tendrán una precisión de un decimal al definirlos en el menú 
....................       Únicamente se harán las comprobaciones de cloro y turbidez cuando se acabe el ciclo de encendido de la depuradora. Mediante el método 
....................       dosificadores será la única forma de que las variables difCloro y difTurbidez tomen un valor superior a 0. Esto ocurrirá cuando sea 
....................       necesario dosificar cloro o floculante, y será cuando se reste cloro en una cantidad proporcional al tiempo de desbordamiento del 
....................       timer 1. 
....................    */ 
....................    // Asignamos 15536 cuentas al timer 1, para que así se desborde tras 50000 cuentas (0.2 segundos) 
....................    set_timer1(15536); 
*
0A24:  MOVLW  3C
0A26:  MOVWF  FCF
0A28:  MOVLW  B0
0A2A:  MOVWF  FCE
....................  
....................    if (difCloro>0.0){ 
0A2C:  CLRF   7E
0A2E:  CLRF   7D
0A30:  CLRF   7C
0A32:  CLRF   7B
0A34:  MOVFF  28,82
0A38:  MOVFF  27,81
0A3C:  MOVFF  26,80
0A40:  MOVFF  25,7F
0A44:  RCALL  0742
0A46:  BNC   0A82
....................       // Resta 0.1 a la diferencia de cloro (para que así hayan pasado 0.2 segundos) y pone el pin a 1 
....................       difCloro-=0.1; 
0A48:  BSF    FD8.1
0A4A:  MOVFF  28,7E
0A4E:  MOVFF  27,7D
0A52:  MOVFF  26,7C
0A56:  MOVFF  25,7B
0A5A:  MOVLW  CD
0A5C:  MOVWF  x82
0A5E:  MOVLW  CC
0A60:  MOVWF  x81
0A62:  MOVLW  4C
0A64:  MOVWF  x80
0A66:  MOVLW  7B
0A68:  MOVWF  7F
0A6A:  RCALL  07B8
0A6C:  MOVFF  03,28
0A70:  MOVFF  02,27
0A74:  MOVFF  01,26
0A78:  MOVFF  00,25
....................       output_high(PIN_C1); 
0A7C:  BCF    F94.1
0A7E:  BSF    F8B.1
....................    } 
....................    else{ 
0A80:  BRA    0A86
....................       // Una vez no haya que dosificar más, se pone el pin a 0 
....................       output_low(PIN_C1); 
0A82:  BCF    F94.1
0A84:  BCF    F8B.1
....................    } 
....................    // Se opera de la misma forma con la turbidez 
....................    if (difTurbidez>0.0){ 
0A86:  CLRF   7E
0A88:  CLRF   7D
0A8A:  CLRF   7C
0A8C:  CLRF   7B
0A8E:  MOVFF  2C,82
0A92:  MOVFF  2B,81
0A96:  MOVFF  2A,80
0A9A:  MOVFF  29,7F
0A9E:  RCALL  0742
0AA0:  BNC   0ADC
....................       difTurbidez-=0.1; 
0AA2:  BSF    FD8.1
0AA4:  MOVFF  2C,7E
0AA8:  MOVFF  2B,7D
0AAC:  MOVFF  2A,7C
0AB0:  MOVFF  29,7B
0AB4:  MOVLW  CD
0AB6:  MOVWF  x82
0AB8:  MOVLW  CC
0ABA:  MOVWF  x81
0ABC:  MOVLW  4C
0ABE:  MOVWF  x80
0AC0:  MOVLW  7B
0AC2:  MOVWF  7F
0AC4:  RCALL  07B8
0AC6:  MOVFF  03,2C
0ACA:  MOVFF  02,2B
0ACE:  MOVFF  01,2A
0AD2:  MOVFF  00,29
....................       output_high(PIN_C2); 
0AD6:  BCF    F94.2
0AD8:  BSF    F8B.2
....................    } 
....................    else{ 
0ADA:  BRA    0AE0
....................       output_low(PIN_C2); 
0ADC:  BCF    F94.2
0ADE:  BCF    F8B.2
....................    } 
.................... } 
....................  
0AE0:  BCF    F9E.0
0AE2:  GOTO   0070
.................... #int_EXT 
.................... void manejo_ext(){ 
....................    /* 
....................       La interrupción externa saltará cada vez que se inicie o termine el ciclo de funcionamiento de la depuradora. Es decir, cuando salte 
....................       una alarma en el PCF8583. Dependiendo de un flag que indica si la depuradora está o no encendida, se pondrá en marcha o se detendrá 
....................       el motor de la depuradora. 
....................    */ 
....................    flagDepuradora=1; 
0AE6:  MOVLW  01
0AE8:  MOVWF  32
.................... } 
....................  
0AEA:  BCF    FF2.1
0AEC:  GOTO   0070
.................... #int_EXT1 
.................... void manejo_ext1(){ 
....................    // Esta interrupción externa saltará cuando se quiera acceder al menú de usuario 
....................    flag=1;  // Simplemente se activa un flag que indica que se quiere acceder al menú 
0AF0:  MOVLW  01
0AF2:  MOVWF  31
.................... } 
....................  
....................  
....................  
0AF4:  BCF    FF0.0
0AF6:  GOTO   0070
.................... void mostrar_lcd(){ 
....................    /* 
....................       Este método mostrará por la pantalla del LCD varios valores de control de la piscina. Concretamente, iniciará mostrando la cantidad 
....................       de cloro y turbidez entre 0 y 5 voltios que ha medido, así como la temperatura del agua y la hora en la que la ha medida. Serán estos 
....................       últimos valores los que se quedarán en el LCD cada vez que el PIC se vaya a dormir. 
....................    */ 
....................    float temperature, cloro, turbidez;          // Variables de los datos medidos en este momento 
....................    lcd_send_byte(0,2); 
*
1F04:  CLRF   73
1F06:  MOVLW  02
1F08:  MOVWF  74
1F0A:  CALL   0B66
....................    PCF8583_read_datetime(&dt);                  // Lectura del RTC 
1F0E:  CLRF   60
1F10:  MOVLW  44
1F12:  MOVWF  5F
1F14:  BRA    19DA
....................    temperature = ds1820_read();                 // Lectura de temperatura 
1F16:  RCALL  1824
1F18:  MOVFF  03,56
1F1C:  MOVFF  02,55
1F20:  MOVFF  01,54
1F24:  MOVFF  00,53
....................    strcpy(weekday, weekday_names[dt.weekday]);  // ptr=strncpy (s1, s2,  n) 
1F28:  MOVF   4A,W
1F2A:  MULLW  0A
1F2C:  MOVF   FF3,W
1F2E:  CLRF   03
1F30:  MOVWF  5F
1F32:  CLRF   FEA
1F34:  MOVLW  3A
1F36:  MOVWF  FE9
1F38:  MOVFF  FF2,60
1F3C:  BCF    FF2.7
1F3E:  MOVF   5F,W
1F40:  CALL   00B4
1F44:  TBLRD*-
1F46:  TBLRD*+
1F48:  MOVF   FF5,W
1F4A:  MOVWF  FEE
1F4C:  IORLW  00
1F4E:  BNZ   1F46
1F50:  BTFSC  60.7
1F52:  BSF    FF2.7
....................                                                 // Copy up to n characters s2->s1 
....................    // Seleccionamos el canal analógico correspondiente al cloro y lo leemos 
....................    set_adc_channel(0); 
1F54:  MOVLW  00
1F56:  MOVWF  01
1F58:  MOVF   FC2,W
1F5A:  ANDLW  C3
1F5C:  IORWF  01,W
1F5E:  MOVWF  FC2
....................    delay_us(10); 
1F60:  CLRWDT
1F62:  MOVLW  06
1F64:  MOVWF  00
1F66:  DECFSZ 00,F
1F68:  BRA    1F66
....................    cloro=read_adc(); 
1F6A:  BSF    FC2.1
1F6C:  BTFSC  FC2.1
1F6E:  BRA    1F6C
1F70:  MOVF   FC4,W
1F72:  CLRF   62
1F74:  MOVWF  61
1F76:  RCALL  1B98
1F78:  MOVFF  03,5A
1F7C:  MOVFF  02,59
1F80:  MOVFF  01,58
1F84:  MOVFF  00,57
....................    cloro=cloro*5/255;         // Normalizamos el valor entre 0 y 5 
1F88:  MOVFF  5A,71
1F8C:  MOVFF  59,70
1F90:  MOVFF  58,6F
1F94:  MOVFF  57,6E
1F98:  CLRF   75
1F9A:  CLRF   74
1F9C:  MOVLW  20
1F9E:  MOVWF  73
1FA0:  MOVLW  81
1FA2:  MOVWF  72
1FA4:  RCALL  1BD0
1FA6:  MOVFF  00,5F
1FAA:  MOVFF  01,60
1FAE:  MOVFF  02,61
1FB2:  MOVFF  03,62
1FB6:  MOVFF  03,6F
1FBA:  MOVFF  02,6E
1FBE:  MOVFF  01,6D
1FC2:  MOVFF  00,6C
1FC6:  CLRF   73
1FC8:  CLRF   72
1FCA:  MOVLW  7F
1FCC:  MOVWF  71
1FCE:  MOVLW  86
1FD0:  MOVWF  70
1FD2:  CALL   16C8
1FD6:  MOVFF  03,5A
1FDA:  MOVFF  02,59
1FDE:  MOVFF  01,58
1FE2:  MOVFF  00,57
....................    // Ahora se hará lo mismo con la turbidez 
....................    set_adc_channel(1); 
1FE6:  MOVLW  04
1FE8:  MOVWF  01
1FEA:  MOVF   FC2,W
1FEC:  ANDLW  C3
1FEE:  IORWF  01,W
1FF0:  MOVWF  FC2
....................    delay_us(10); 
1FF2:  CLRWDT
1FF4:  MOVLW  06
1FF6:  MOVWF  00
1FF8:  DECFSZ 00,F
1FFA:  BRA    1FF8
....................    turbidez=read_adc(); 
1FFC:  BSF    FC2.1
1FFE:  BTFSC  FC2.1
2000:  BRA    1FFE
2002:  MOVF   FC4,W
2004:  CLRF   62
2006:  MOVWF  61
2008:  RCALL  1B98
200A:  MOVFF  03,5E
200E:  MOVFF  02,5D
2012:  MOVFF  01,5C
2016:  MOVFF  00,5B
....................    turbidez=turbidez*5/255; 
201A:  MOVFF  5E,71
201E:  MOVFF  5D,70
2022:  MOVFF  5C,6F
2026:  MOVFF  5B,6E
202A:  CLRF   75
202C:  CLRF   74
202E:  MOVLW  20
2030:  MOVWF  73
2032:  MOVLW  81
2034:  MOVWF  72
2036:  RCALL  1BD0
2038:  MOVFF  00,5F
203C:  MOVFF  01,60
2040:  MOVFF  02,61
2044:  MOVFF  03,62
2048:  MOVFF  03,6F
204C:  MOVFF  02,6E
2050:  MOVFF  01,6D
2054:  MOVFF  00,6C
2058:  CLRF   73
205A:  CLRF   72
205C:  MOVLW  7F
205E:  MOVWF  71
2060:  MOVLW  86
2062:  MOVWF  70
2064:  CALL   16C8
2068:  MOVFF  03,5E
206C:  MOVFF  02,5D
2070:  MOVFF  01,5C
2074:  MOVFF  00,5B
....................    // Se muestran los datos por el LCD 
....................    lcd_send_byte(0,1); 
2078:  CLRF   73
207A:  MOVLW  01
207C:  MOVWF  74
207E:  CALL   0B66
....................    lcd_gotoxy(1,1); 
2082:  MOVLW  01
2084:  MOVWF  6F
2086:  MOVWF  70
2088:  CALL   12C6
....................    printf(lcd_putc,"CLORO: %3.2f \nTURBIDEZ: %3.2f ",cloro,turbidez); 
208C:  CLRF   5F
208E:  MOVF   5F,W
2090:  CALL   0486
2094:  INCF   5F,F
2096:  MOVWF  00
2098:  MOVWF  6E
209A:  CALL   12E8
209E:  MOVLW  07
20A0:  SUBWF  5F,W
20A2:  BNZ   208E
20A4:  MOVLW  02
20A6:  MOVWF  FE9
20A8:  MOVFF  5A,64
20AC:  MOVFF  59,63
20B0:  MOVFF  58,62
20B4:  MOVFF  57,61
20B8:  MOVWF  65
20BA:  RCALL  1D7E
20BC:  MOVLW  0C
20BE:  MOVWF  60
20C0:  MOVF   60,W
20C2:  CALL   0486
20C6:  INCF   60,F
20C8:  MOVWF  00
20CA:  MOVWF  6E
20CC:  CALL   12E8
20D0:  MOVLW  18
20D2:  SUBWF  60,W
20D4:  BNZ   20C0
20D6:  MOVLW  02
20D8:  MOVWF  FE9
20DA:  MOVFF  5E,64
20DE:  MOVFF  5D,63
20E2:  MOVFF  5C,62
20E6:  MOVFF  5B,61
20EA:  MOVWF  65
20EC:  RCALL  1D7E
20EE:  MOVLW  20
20F0:  MOVWF  6E
20F2:  CALL   12E8
....................    delay_ms(1000); 
20F6:  MOVLW  04
20F8:  MOVWF  5F
20FA:  MOVLW  FA
20FC:  MOVWF  75
20FE:  CALL   0AFA
2102:  DECFSZ 5F,F
2104:  BRA    20FA
....................    // Espera un segundo tras mostrar cloro y turbidez para luego mostrar hora y fecha 
....................    lcd_send_byte(0,1); 
2106:  CLRF   73
2108:  MOVLW  01
210A:  MOVWF  74
210C:  CALL   0B66
....................    lcd_gotoxy(1,1); 
2110:  MOVLW  01
2112:  MOVWF  6F
2114:  MOVWF  70
2116:  CALL   12C6
....................    printf(lcd_putc,"TEMP: %3.1f %cC \nHora: %u:%2u:%2u",temperature,223,dt.hours, dt.minutes,dt.seconds ); 
211A:  CLRF   5F
211C:  MOVF   5F,W
211E:  CALL   04C0
2122:  INCF   5F,F
2124:  MOVWF  00
2126:  MOVWF  6E
2128:  CALL   12E8
212C:  MOVLW  06
212E:  SUBWF  5F,W
2130:  BNZ   211C
2132:  MOVLW  02
2134:  MOVWF  FE9
2136:  MOVFF  56,64
213A:  MOVFF  55,63
213E:  MOVFF  54,62
2142:  MOVFF  53,61
2146:  MOVLW  01
2148:  MOVWF  65
214A:  RCALL  1D7E
214C:  MOVLW  20
214E:  MOVWF  6E
2150:  CALL   12E8
2154:  MOVLW  DF
2156:  MOVWF  6E
2158:  CALL   12E8
215C:  MOVLW  0E
215E:  MOVWF  60
2160:  MOVF   60,W
2162:  CALL   04C0
2166:  INCF   60,F
2168:  MOVWF  00
216A:  MOVWF  6E
216C:  CALL   12E8
2170:  MOVLW  17
2172:  SUBWF  60,W
2174:  BNZ   2160
2176:  MOVFF  46,61
217A:  MOVLW  1B
217C:  MOVWF  62
217E:  CALL   13FE
2182:  MOVLW  3A
2184:  MOVWF  6E
2186:  CALL   12E8
218A:  MOVFF  45,61
218E:  MOVLW  11
2190:  MOVWF  62
2192:  CALL   13FE
2196:  MOVLW  3A
2198:  MOVWF  6E
219A:  CALL   12E8
219E:  MOVFF  44,61
21A2:  MOVLW  11
21A4:  MOVWF  62
21A6:  CALL   13FE
....................    delay_ms(1000); 
21AA:  MOVLW  04
21AC:  MOVWF  5F
21AE:  MOVLW  FA
21B0:  MOVWF  75
21B2:  CALL   0AFA
21B6:  DECFSZ 5F,F
21B8:  BRA    21AE
.................... } 
21BA:  RETLW  00
....................  
.................... void mostrar_rs232(){ 
....................    leeEeprom(); 
*
23B2:  CALL   0DFA
....................    printf("Lectura de Eeprom hecha a las %u:%2u:%2u\n\r\n\r",dt.hours, dt.minutes,dt.seconds); 
23B6:  CLRF   53
23B8:  MOVF   53,W
23BA:  CALL   04FC
23BE:  INCF   53,F
23C0:  MOVWF  00
23C2:  MOVF   00,W
23C4:  BTFSS  F9E.4
23C6:  BRA    23C4
23C8:  MOVWF  FAD
23CA:  MOVLW  1E
23CC:  SUBWF  53,W
23CE:  BNZ   23B8
23D0:  MOVFF  46,54
23D4:  MOVLW  1B
23D6:  MOVWF  55
23D8:  RCALL  21BC
23DA:  MOVLW  3A
23DC:  BTFSS  F9E.4
23DE:  BRA    23DC
23E0:  MOVWF  FAD
23E2:  MOVFF  45,54
23E6:  MOVLW  11
23E8:  MOVWF  55
23EA:  RCALL  21BC
23EC:  MOVLW  3A
23EE:  BTFSS  F9E.4
23F0:  BRA    23EE
23F2:  MOVWF  FAD
23F4:  MOVFF  44,54
23F8:  MOVLW  11
23FA:  MOVWF  55
23FC:  RCALL  21BC
23FE:  MOVLW  28
2400:  MOVWF  54
2402:  MOVF   54,W
2404:  CALL   04FC
2408:  INCF   54,F
240A:  MOVWF  00
240C:  MOVF   00,W
240E:  BTFSS  F9E.4
2410:  BRA    240E
2412:  MOVWF  FAD
2414:  MOVLW  2C
2416:  SUBWF  54,W
2418:  BNZ   2402
....................    printf("Hora inicio ciclo depuradora: %u:%u\n\r",horaInicio,minutoInicio); 
241A:  CLRF   53
241C:  MOVF   53,W
241E:  CALL   0544
2422:  INCF   53,F
2424:  MOVWF  00
2426:  MOVF   00,W
2428:  BTFSS  F9E.4
242A:  BRA    2428
242C:  MOVWF  FAD
242E:  MOVLW  1E
2430:  SUBWF  53,W
2432:  BNZ   241C
2434:  MOVFF  2D,54
2438:  MOVLW  1B
243A:  MOVWF  55
243C:  RCALL  21BC
243E:  MOVLW  3A
2440:  BTFSS  F9E.4
2442:  BRA    2440
2444:  MOVWF  FAD
2446:  MOVFF  2E,54
244A:  MOVLW  1B
244C:  MOVWF  55
244E:  RCALL  21BC
2450:  MOVLW  0A
2452:  BTFSS  F9E.4
2454:  BRA    2452
2456:  MOVWF  FAD
2458:  MOVLW  0D
245A:  BTFSS  F9E.4
245C:  BRA    245A
245E:  MOVWF  FAD
....................    printf("Hora fin ciclo depuradora: %u:%u\n\r",horaFin,minutoFin); 
2460:  CLRF   53
2462:  MOVF   53,W
2464:  CALL   0584
2468:  INCF   53,F
246A:  MOVWF  00
246C:  MOVF   00,W
246E:  BTFSS  F9E.4
2470:  BRA    246E
2472:  MOVWF  FAD
2474:  MOVLW  1B
2476:  SUBWF  53,W
2478:  BNZ   2462
247A:  MOVFF  2F,54
247E:  MOVLW  1B
2480:  MOVWF  55
2482:  RCALL  21BC
2484:  MOVLW  3A
2486:  BTFSS  F9E.4
2488:  BRA    2486
248A:  MOVWF  FAD
248C:  MOVFF  30,54
2490:  MOVLW  1B
2492:  MOVWF  55
2494:  RCALL  21BC
2496:  MOVLW  0A
2498:  BTFSS  F9E.4
249A:  BRA    2498
249C:  MOVWF  FAD
249E:  MOVLW  0D
24A0:  BTFSS  F9E.4
24A2:  BRA    24A0
24A4:  MOVWF  FAD
....................    printf("Temperatura minima deseada: %2.1f\n\r",tempDeseada); 
24A6:  CLRF   53
24A8:  MOVF   53,W
24AA:  CALL   05C2
24AE:  INCF   53,F
24B0:  MOVWF  00
24B2:  MOVF   00,W
24B4:  BTFSS  F9E.4
24B6:  BRA    24B4
24B8:  MOVWF  FAD
24BA:  MOVLW  1C
24BC:  SUBWF  53,W
24BE:  BNZ   24A8
24C0:  MOVLW  01
24C2:  MOVWF  FE9
24C4:  MOVFF  1C,57
24C8:  MOVFF  1B,56
24CC:  MOVFF  1A,55
24D0:  MOVFF  19,54
24D4:  MOVWF  58
24D6:  RCALL  222C
24D8:  MOVLW  0A
24DA:  BTFSS  F9E.4
24DC:  BRA    24DA
24DE:  MOVWF  FAD
24E0:  MOVLW  0D
24E2:  BTFSS  F9E.4
24E4:  BRA    24E2
24E6:  MOVWF  FAD
....................    printf("Nivel minimo de cloro exigido: %1.1f\n\r",cloroDeseado); 
24E8:  CLRF   53
24EA:  MOVF   53,W
24EC:  CALL   0600
24F0:  INCF   53,F
24F2:  MOVWF  00
24F4:  MOVF   00,W
24F6:  BTFSS  F9E.4
24F8:  BRA    24F6
24FA:  MOVWF  FAD
24FC:  MOVLW  1F
24FE:  SUBWF  53,W
2500:  BNZ   24EA
2502:  MOVLW  89
2504:  MOVWF  FE9
2506:  MOVFF  20,57
250A:  MOVFF  1F,56
250E:  MOVFF  1E,55
2512:  MOVFF  1D,54
2516:  MOVLW  01
2518:  MOVWF  58
251A:  RCALL  222C
251C:  MOVLW  0A
251E:  BTFSS  F9E.4
2520:  BRA    251E
2522:  MOVWF  FAD
2524:  MOVLW  0D
2526:  BTFSS  F9E.4
2528:  BRA    2526
252A:  MOVWF  FAD
....................    printf("Nivel maximo de turbidez permitida: %1.1f\n\r",turbidezDeseada); 
252C:  CLRF   53
252E:  MOVF   53,W
2530:  CALL   0642
2534:  INCF   53,F
2536:  MOVWF  00
2538:  MOVF   00,W
253A:  BTFSS  F9E.4
253C:  BRA    253A
253E:  MOVWF  FAD
2540:  MOVLW  24
2542:  SUBWF  53,W
2544:  BNZ   252E
2546:  MOVLW  89
2548:  MOVWF  FE9
254A:  MOVFF  24,57
254E:  MOVFF  23,56
2552:  MOVFF  22,55
2556:  MOVFF  21,54
255A:  MOVLW  01
255C:  MOVWF  58
255E:  RCALL  222C
2560:  MOVLW  0A
2562:  BTFSS  F9E.4
2564:  BRA    2562
2566:  MOVWF  FAD
2568:  MOVLW  0D
256A:  BTFSS  F9E.4
256C:  BRA    256A
256E:  MOVWF  FAD
....................    printf("------------------------------------\n\r"); 
2570:  CLRF   53
2572:  MOVF   53,W
2574:  CALL   0688
2578:  IORLW  00
257A:  BZ    2586
257C:  INCF   53,F
257E:  BTFSS  F9E.4
2580:  BRA    257E
2582:  MOVWF  FAD
2584:  BRA    2572
.................... } 
2586:  RETLW  00
....................  
.................... void comprobar_temperatura(){ 
....................    /* 
....................       Este método hará una medición de la temperatura y además comprobará si debe o no encender el calentador del 
....................       agua. Se permite un margen de 2 grados centígrados respecto el valor deseado antes de encender el calentador. 
....................       El método saltará cada vez que el PIC despierte, normalmente avisado por el wdt, cada algo más de 2 minutos. 
....................    */ 
....................    float temperature; 
....................    temperature = ds1820_read(); 
*
18BA:  RCALL  1824
18BC:  MOVFF  03,5C
18C0:  MOVFF  02,5B
18C4:  MOVFF  01,5A
18C8:  MOVFF  00,59
....................    if (temperature <= tempdeseada - 2.0){    // Damos histéresis de 2ºC 
18CC:  BSF    FD8.1
18CE:  CLRF   18
18D0:  BTFSC  FF2.7
18D2:  BSF    18.7
18D4:  BCF    FF2.7
18D6:  MOVFF  1C,7E
18DA:  MOVFF  1B,7D
18DE:  MOVFF  1A,7C
18E2:  MOVFF  19,7B
18E6:  CLRF   x82
18E8:  CLRF   x81
18EA:  CLRF   x80
18EC:  MOVLW  80
18EE:  MOVWF  7F
18F0:  CALL   07B8
18F4:  BTFSC  18.7
18F6:  BSF    FF2.7
18F8:  CLRF   18
18FA:  BTFSC  FF2.7
18FC:  BSF    18.7
18FE:  BCF    FF2.7
1900:  MOVFF  5C,7E
1904:  MOVFF  5B,7D
1908:  MOVFF  5A,7C
190C:  MOVFF  59,7B
1910:  MOVFF  03,82
1914:  MOVFF  02,81
1918:  MOVFF  01,80
191C:  MOVFF  00,7F
1920:  CALL   0742
1924:  BTFSC  18.7
1926:  BSF    FF2.7
1928:  BC    192C
192A:  BNZ   1932
....................       output_high(PIN_C0); 
192C:  BCF    F94.0
192E:  BSF    F8B.0
....................    } 
....................    else{ 
1930:  BRA    1936
....................       output_low(PIN_C0); 
1932:  BCF    F94.0
1934:  BCF    F8B.0
....................    } 
.................... } 
1936:  RETLW  00
....................  
.................... void dosificadores(){ 
....................    /* 
....................       Este método se lanzará cada vez que acabe el ciclo de trabajo de la depuradora. La función del método será leer 
....................       los valores de cloro y turbidez que hay en la piscina en ese momento y compararlos con los valores deseados 
....................       definidos por el usuario. En caso de necesitar dosificarse cloro o floculante, las variables difCloro y difTurbidez 
....................       tendrán un valor mayor que 0, y por tanto la rutina del timer 1 empezaría a dosificar durante un tiempo proporcional 
....................       a esta diferencia, que se irá reduciendo con sucesivas llamadas a la rutina de interrupción del timer 1. 
....................    */ 
....................    float cloro, turbidez; 
....................    // Medimos los niveles actuales de cloro y turbidez 
....................    set_adc_channel(0); 
*
2588:  MOVLW  00
258A:  MOVWF  01
258C:  MOVF   FC2,W
258E:  ANDLW  C3
2590:  IORWF  01,W
2592:  MOVWF  FC2
....................    delay_us(10); 
2594:  CLRWDT
2596:  MOVLW  06
2598:  MOVWF  00
259A:  DECFSZ 00,F
259C:  BRA    259A
....................    cloro=read_adc(); 
259E:  BSF    FC2.1
25A0:  BTFSC  FC2.1
25A2:  BRA    25A0
25A4:  MOVF   FC4,W
25A6:  CLRF   62
25A8:  MOVWF  61
25AA:  CALL   1B98
25AE:  MOVFF  03,5C
25B2:  MOVFF  02,5B
25B6:  MOVFF  01,5A
25BA:  MOVFF  00,59
....................    cloro=cloro*5/255; 
25BE:  MOVFF  5C,71
25C2:  MOVFF  5B,70
25C6:  MOVFF  5A,6F
25CA:  MOVFF  59,6E
25CE:  CLRF   75
25D0:  CLRF   74
25D2:  MOVLW  20
25D4:  MOVWF  73
25D6:  MOVLW  81
25D8:  MOVWF  72
25DA:  CALL   1BD0
25DE:  MOVFF  00,61
25E2:  MOVFF  01,62
25E6:  MOVFF  02,63
25EA:  MOVFF  03,64
25EE:  MOVFF  03,6F
25F2:  MOVFF  02,6E
25F6:  MOVFF  01,6D
25FA:  MOVFF  00,6C
25FE:  CLRF   73
2600:  CLRF   72
2602:  MOVLW  7F
2604:  MOVWF  71
2606:  MOVLW  86
2608:  MOVWF  70
260A:  CALL   16C8
260E:  MOVFF  03,5C
2612:  MOVFF  02,5B
2616:  MOVFF  01,5A
261A:  MOVFF  00,59
....................    set_adc_channel(1); 
261E:  MOVLW  04
2620:  MOVWF  01
2622:  MOVF   FC2,W
2624:  ANDLW  C3
2626:  IORWF  01,W
2628:  MOVWF  FC2
....................    delay_us(10); 
262A:  CLRWDT
262C:  MOVLW  06
262E:  MOVWF  00
2630:  DECFSZ 00,F
2632:  BRA    2630
....................    turbidez=read_adc(); 
2634:  BSF    FC2.1
2636:  BTFSC  FC2.1
2638:  BRA    2636
263A:  MOVF   FC4,W
263C:  CLRF   62
263E:  MOVWF  61
2640:  CALL   1B98
2644:  MOVFF  03,60
2648:  MOVFF  02,5F
264C:  MOVFF  01,5E
2650:  MOVFF  00,5D
....................    turbidez=turbidez*5/255; 
2654:  MOVFF  60,71
2658:  MOVFF  5F,70
265C:  MOVFF  5E,6F
2660:  MOVFF  5D,6E
2664:  CLRF   75
2666:  CLRF   74
2668:  MOVLW  20
266A:  MOVWF  73
266C:  MOVLW  81
266E:  MOVWF  72
2670:  CALL   1BD0
2674:  MOVFF  00,61
2678:  MOVFF  01,62
267C:  MOVFF  02,63
2680:  MOVFF  03,64
2684:  MOVFF  03,6F
2688:  MOVFF  02,6E
268C:  MOVFF  01,6D
2690:  MOVFF  00,6C
2694:  CLRF   73
2696:  CLRF   72
2698:  MOVLW  7F
269A:  MOVWF  71
269C:  MOVLW  86
269E:  MOVWF  70
26A0:  CALL   16C8
26A4:  MOVFF  03,60
26A8:  MOVFF  02,5F
26AC:  MOVFF  01,5E
26B0:  MOVFF  00,5D
....................    // Calculamos la diferencia con los valores deseados 
....................    difCloro=cloroDeseado-cloro;              // En el caso del cloro, la diferencia es positiva cuando hay menos cloro del deseado 
26B4:  BSF    FD8.1
26B6:  CLRF   18
26B8:  BTFSC  FF2.7
26BA:  BSF    18.7
26BC:  BCF    FF2.7
26BE:  MOVFF  20,7E
26C2:  MOVFF  1F,7D
26C6:  MOVFF  1E,7C
26CA:  MOVFF  1D,7B
26CE:  MOVFF  5C,82
26D2:  MOVFF  5B,81
26D6:  MOVFF  5A,80
26DA:  MOVFF  59,7F
26DE:  CALL   07B8
26E2:  BTFSC  18.7
26E4:  BSF    FF2.7
26E6:  MOVFF  03,28
26EA:  MOVFF  02,27
26EE:  MOVFF  01,26
26F2:  MOVFF  00,25
....................    difTurbidez=turbidez-turbidezDeseada;     // En el caso de la turbidez, habrá que dosificar cuando hay más turbidez de la deseada 
26F6:  BSF    FD8.1
26F8:  CLRF   18
26FA:  BTFSC  FF2.7
26FC:  BSF    18.7
26FE:  BCF    FF2.7
2700:  MOVFF  60,7E
2704:  MOVFF  5F,7D
2708:  MOVFF  5E,7C
270C:  MOVFF  5D,7B
2710:  MOVFF  24,82
2714:  MOVFF  23,81
2718:  MOVFF  22,80
271C:  MOVFF  21,7F
2720:  CALL   07B8
2724:  BTFSC  18.7
2726:  BSF    FF2.7
2728:  MOVFF  03,2C
272C:  MOVFF  02,2B
2730:  MOVFF  01,2A
2734:  MOVFF  00,29
2738:  CLRF   18
273A:  BTFSC  FF2.7
273C:  BSF    18.7
273E:  BCF    FF2.7
....................    // En ambos casos, diferencias negativas (que los niveles sean mejores que los deseados) serán tomadas como cero. 
....................    if (difCloro<0.0) 
2740:  MOVFF  28,7E
2744:  MOVFF  27,7D
2748:  MOVFF  26,7C
274C:  MOVFF  25,7B
2750:  CLRF   x82
2752:  CLRF   x81
2754:  CLRF   x80
2756:  CLRF   7F
2758:  CALL   0742
275C:  BTFSC  18.7
275E:  BSF    FF2.7
2760:  BNC   276A
....................       difCloro=0.0; 
2762:  CLRF   28
2764:  CLRF   27
2766:  CLRF   26
2768:  CLRF   25
276A:  CLRF   18
276C:  BTFSC  FF2.7
276E:  BSF    18.7
2770:  BCF    FF2.7
....................    if (difTurbidez<0.0) 
2772:  MOVFF  2C,7E
2776:  MOVFF  2B,7D
277A:  MOVFF  2A,7C
277E:  MOVFF  29,7B
2782:  CLRF   x82
2784:  CLRF   x81
2786:  CLRF   x80
2788:  CLRF   7F
278A:  CALL   0742
278E:  BTFSC  18.7
2790:  BSF    FF2.7
2792:  BNC   279C
....................       difTurbidez=0.0; 
2794:  CLRF   2C
2796:  CLRF   2B
2798:  CLRF   2A
279A:  CLRF   29
.................... } 
279C:  GOTO   27CC (RETURN)
....................  
.................... void funcionaDepuradora(){ 
....................    /* 
....................       Este método será el que determine el funcionamiento de la depuradora, con su ciclo de encendido y apagado, según sea 
....................       el turno que corresponda. Al final, vuelve a poner el flag de la depuradora a cero. 
....................    */ 
....................    if (depuradoraOn==0){ 
27A0:  MOVF   33,F
27A2:  BNZ   27CA
....................       // En caso de que la depuradora esté apagada 
....................       PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 0x04); // Pone el flag de alarma del PCF8583 a 0. 
27A4:  CLRF   68
27A6:  MOVLW  04
27A8:  MOVWF  69
27AA:  CALL   0CC6
....................       dtalarm.hours=horaFin;                             // Modifica la hora de la variable dtalarm 
27AE:  MOVFF  2F,4D
....................       dtalarm.minutes=minutoFin;                         // También los minutos 
27B2:  MOVFF  30,4C
....................       PCF8583_set_alarmtime(&dtalarm);                   // Esta nueva hora se introduce al PCF8583 (será la correspondiente a la próxima 
27B6:  CLRF   5B
27B8:  MOVLW  4B
27BA:  MOVWF  5A
27BC:  CALL   0D0E
....................                                                          // vez que debe avisar al PIC -> cuando acabe el ciclo de trabajo de la depuradora) 
....................       output_high(PIN_C5);                               // Activa el pin de salida del motor de la depuradora 
27C0:  BCF    F94.5
27C2:  BSF    F8B.5
....................       depuradoraOn=1;                                    // Ahora el flag indica que la depuradora no está funcionando 
27C4:  MOVLW  01
27C6:  MOVWF  33
....................    } 
....................    else{ 
27C8:  BRA    27EE
....................       // En caso de que esté funcionando 
....................       dosificadores();                                   // Se inicia el método que determina si es necesario o no dosificar cloro y floculante 
27CA:  BRA    2588
....................       PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 0x04); // Pone el flag de alarma del PCF8583 a 0 
27CC:  CLRF   68
27CE:  MOVLW  04
27D0:  MOVWF  69
27D2:  CALL   0CC6
....................       dtalarm.hours=horaInicio;                          // Modifica la hora de la variable dtalarm 
27D6:  MOVFF  2D,4D
....................       dtalarm.minutes=minutoInicio;                      // También los minutos 
27DA:  MOVFF  2E,4C
....................       PCF8583_set_alarmtime(&dtalarm);                   // Ahora el PCF8583 tendrá como nueva alarma la hora de inicio del próximo ciclo 
27DE:  CLRF   5B
27E0:  MOVLW  4B
27E2:  MOVWF  5A
27E4:  CALL   0D0E
....................       output_low(PIN_C5);                                // Se pone a 0 el pin de salida al motor de la depuradora 
27E8:  BCF    F94.5
27EA:  BCF    F8B.5
....................       depuradoraOn=0;                                    // El flag vuelve a indicar que la depuradora no está funcionando 
27EC:  CLRF   33
....................    } 
....................    flagDepuradora=0; 
27EE:  CLRF   32
.................... } 
27F0:  RETLW  00
....................  
.................... //================================= 
.................... void main() 
.................... { 
*
3DFE:  CLRF   FF8
3E00:  BCF    FD0.7
3E02:  BSF    0D.7
3E04:  CLRF   FEA
3E06:  CLRF   FE9
3E08:  BCF    FB8.3
3E0A:  MOVLW  19
3E0C:  MOVWF  FAF
3E0E:  MOVLW  22
3E10:  MOVWF  FAC
3E12:  MOVLW  90
3E14:  MOVWF  FAB
3E16:  MOVF   FC1,W
3E18:  ANDLW  C0
3E1A:  IORLW  0F
3E1C:  MOVWF  FC1
3E1E:  MOVLW  07
3E20:  MOVWF  FB4
....................    // Ambas interrupciones externas estarán disparadas por flanco de bajada 
....................    ext_int_edge(0,H_TO_L); 
3E22:  BCF    FF1.6
....................    ext_int_edge(1,H_TO_L); 
3E24:  BCF    FF1.5
....................    // Se habilitan las interrupciones 
....................    enable_interrupts(GLOBAL); 
3E26:  MOVLW  C0
3E28:  IORWF  FF2,F
....................    enable_interrupts(INT_EXT); 
3E2A:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1); 
3E2C:  BSF    FF0.3
....................    enable_interrupts(INT_TIMER1); 
3E2E:  BSF    F9D.0
....................     
....................    // Configuración 
....................    setup_adc_ports(NO_ANALOGS); 
3E30:  MOVF   FC1,W
3E32:  ANDLW  C0
3E34:  IORLW  0F
3E36:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
3E38:  BCF    FC2.0
....................    // Configuración de los timers 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1);  // Prescaler de 1 en el timer 0, que será el que afecte al wdt 
3E3A:  MOVLW  88
3E3C:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); // Timer1 con prescaler de 8, y se considera el reloj interno 
3E3E:  MOVLW  B5
3E40:  MOVWF  FCD
....................    setup_timer_2(T2_DISABLED,0,1);           // Timer2 inactivo 
3E42:  MOVLW  00
3E44:  MOVWF  FCA
3E46:  MOVLW  00
3E48:  MOVWF  FCB
....................    setup_comparator(NC_NC_NC_NC); 
3E4A:  MOVLW  07
3E4C:  MOVWF  FB4
3E4E:  MOVF   F92,W
3E50:  CLRWDT
3E52:  MOVLW  06
3E54:  MOVWF  00
3E56:  DECFSZ 00,F
3E58:  BRA    3E56
3E5A:  MOVF   FB4,W
3E5C:  BCF    FA1.6
....................    setup_vref(VREF_LOW|-2); 
3E5E:  MOVLW  FE
3E60:  MOVWF  FB5
3E62:  BSF    F97.5
....................    setup_adc_ports(AN0_TO_AN3);  // RA0 a RA3 entradas analógicas (ver 18F4520.h) 
3E64:  MOVF   FC1,W
3E66:  ANDLW  C0
3E68:  IORLW  0B
3E6A:  MOVWF  FC1
....................    setup_adc(adc_clock_div_32);  // Ajusta tiempo de conversión de cada bit 
3E6C:  MOVF   FC0,W
3E6E:  ANDLW  C0
3E70:  IORLW  02
3E72:  MOVWF  FC0
3E74:  BCF    FC0.7
3E76:  BSF    FC2.0
....................  
....................    set_timer1(15536);   // Se introducen 15536 de inicio al timer1 
3E78:  MOVLW  3C
3E7A:  MOVWF  FCF
3E7C:  MOVLW  B0
3E7E:  MOVWF  FCE
....................    lcd_init();          // Se inicializa el LCD 
3E80:  GOTO   0BA6
....................    lcd_send_byte(0, 1); // Borra LCD 
3E84:  CLRF   73
3E86:  MOVLW  01
3E88:  MOVWF  74
3E8A:  CALL   0B66
....................    printf("Bienvenido al sistema de control de la piscina\n\r\n\r\n\r"); 
3E8E:  CLRF   52
3E90:  MOVF   52,W
3E92:  CALL   06CA
3E96:  IORLW  00
3E98:  BZ    3EA4
3E9A:  INCF   52,F
3E9C:  BTFSS  F9E.4
3E9E:  BRA    3E9C
3EA0:  MOVWF  FAD
3EA2:  BRA    3E90
....................    leeEeprom();         // Se cargarán de EEPROM varias variables para el funcionamiento de la piscina. Concretamente los 
3EA4:  CALL   0DFA
....................                         // valores deseados de temperatura, cloro y turbidez, y la hora de encendido y apagado del motor de 
....................                         // la depuradora. 
....................  
....................    // Se pedirá que se introduzca la hora inicial al sistema 
....................    lcd_putc("Hora actual?"); 
3EA8:  CLRF   52
3EAA:  MOVF   52,W
3EAC:  CALL   071A
3EB0:  IORLW  00
3EB2:  BZ    3EBE
3EB4:  INCF   52,F
3EB6:  MOVWF  6E
3EB8:  CALL   12E8
3EBC:  BRA    3EAA
....................    lcd_gotoxy(1,2); 
3EBE:  MOVLW  01
3EC0:  MOVWF  6F
3EC2:  MOVLW  02
3EC4:  MOVWF  70
3EC6:  CALL   12C6
....................    lcd_putc("Formato: XX:XX"); 
3ECA:  CLRF   52
3ECC:  MOVF   52,W
3ECE:  CALL   0304
3ED2:  IORLW  00
3ED4:  BZ    3EE0
3ED6:  INCF   52,F
3ED8:  MOVWF  6E
3EDA:  CALL   12E8
3EDE:  BRA    3ECC
....................    lcd_gotoxy(10,2); 
3EE0:  MOVLW  0A
3EE2:  MOVWF  6F
3EE4:  MOVLW  02
3EE6:  MOVWF  70
3EE8:  CALL   12C6
....................    ntpl=0; 
3EEC:  CLRF   35
....................    while(ntpl<4){ 
3EEE:  MOVF   35,W
3EF0:  SUBLW  03
3EF2:  BNC   3F92
....................       // Según las teclas que haya pulsado (iré por un dígito u otro de las horas:minutos) 
....................       switch(ntpl){ 
3EF4:  MOVF   35,W
3EF6:  ADDLW  FC
3EF8:  BC    3F90
3EFA:  ADDLW  04
3EFC:  GOTO   4070
....................          case 0:  n1=kbd_getc(); 
3F00:  CALL   132E
3F04:  MOVFF  01,36
....................          if (n1<=2){ 
3F08:  MOVF   36,W
3F0A:  SUBLW  02
3F0C:  BNC   3F2C
....................             printf(lcd_putc,"%u",n1); 
3F0E:  MOVFF  36,61
3F12:  MOVLW  1B
3F14:  MOVWF  62
3F16:  CALL   13FE
....................             ntpl++; 
3F1A:  INCF   35,F
....................             if (n1==2) 
3F1C:  MOVF   36,W
3F1E:  SUBLW  02
3F20:  BNZ   3F28
....................                auxiliar=4; 
3F22:  MOVLW  04
3F24:  MOVWF  34
....................             else 
3F26:  BRA    3F2C
....................                auxiliar=10; 
3F28:  MOVLW  0A
3F2A:  MOVWF  34
....................          } 
....................          break; 
3F2C:  BRA    3F90
....................          case 1:  n2=kbd_getc(); 
3F2E:  CALL   132E
3F32:  MOVFF  01,37
....................          if (n2<auxiliar){ 
3F36:  MOVF   34,W
3F38:  SUBWF  37,W
3F3A:  BC    3F52
....................             printf(lcd_putc,"%u:",n2); 
3F3C:  MOVFF  37,61
3F40:  MOVLW  1B
3F42:  MOVWF  62
3F44:  CALL   13FE
3F48:  MOVLW  3A
3F4A:  MOVWF  6E
3F4C:  CALL   12E8
....................             ntpl++; 
3F50:  INCF   35,F
....................          } 
....................          break; 
3F52:  BRA    3F90
....................          case 2:  n3=kbd_getc(); 
3F54:  CALL   132E
3F58:  MOVFF  01,38
....................          if (n3<=5){ 
3F5C:  MOVF   38,W
3F5E:  SUBLW  05
3F60:  BNC   3F70
....................             printf(lcd_putc,"%u",n3); 
3F62:  MOVFF  38,61
3F66:  MOVLW  1B
3F68:  MOVWF  62
3F6A:  CALL   13FE
....................             ntpl++; 
3F6E:  INCF   35,F
....................          } 
....................          break; 
3F70:  BRA    3F90
....................          case 3:  n4=kbd_getc(); 
3F72:  CALL   132E
3F76:  MOVFF  01,39
....................          if (n4<10){ 
3F7A:  MOVF   39,W
3F7C:  SUBLW  09
3F7E:  BNC   3F8E
....................             printf(lcd_putc,"%u",n4); 
3F80:  MOVFF  39,61
3F84:  MOVLW  1B
3F86:  MOVWF  62
3F88:  CALL   13FE
....................             ntpl++; 
3F8C:  INCF   35,F
....................          } 
....................          break; 
3F8E:  BRA    3F90
....................       } 
....................    } 
3F90:  BRA    3EEE
....................    // Inicialización de los flags 
....................    flag=0;           // El flag del menú empezará inactivo (para acceder al menú habrá que pulsar su botón) 
3F92:  CLRF   31
....................    flagDepuradora=0; // Y lo mismo el flag de activación o desactivación del motor de la depuradora 
3F94:  CLRF   32
....................    depuradoraOn=0;   // La depuradora se supone apagada de inicio 
3F96:  CLRF   33
....................     
....................    // Introducción de la hora elegida 
....................    dt.hours=10*n1+n2; 
3F98:  MOVF   36,W
3F9A:  MULLW  0A
3F9C:  MOVF   FF3,W
3F9E:  ADDWF  37,W
3FA0:  MOVWF  46
....................    dt.minutes=10*n3+n4; 
3FA2:  MOVF   38,W
3FA4:  MULLW  0A
3FA6:  MOVF   FF3,W
3FA8:  ADDWF  39,W
3FAA:  MOVWF  45
....................    PCF8583_init(); 
3FAC:  GOTO   1464
....................    PCF8583_set_datetime(&dt);    // Puesta en fecha-hora*/ 
3FB0:  CLRF   53
3FB2:  MOVLW  44
3FB4:  MOVWF  52
3FB6:  GOTO   146E
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 0x04);    // Activamos los campos de alarma 
3FBA:  CLRF   68
3FBC:  MOVLW  04
3FBE:  MOVWF  69
3FC0:  CALL   0CC6
....................    PCF8583_write_byte(PCF8583_ALARM_CONTROL_REG, 0x90);  // Introducimos alarma diara 
3FC4:  MOVLW  08
3FC6:  MOVWF  68
3FC8:  MOVLW  90
3FCA:  MOVWF  69
3FCC:  CALL   0CC6
....................    delay_ms(30); 
3FD0:  MOVLW  1E
3FD2:  MOVWF  75
3FD4:  CALL   0AFA
....................  
....................    lcd_send_byte(0,1); 
3FD8:  CLRF   73
3FDA:  MOVLW  01
3FDC:  MOVWF  74
3FDE:  CALL   0B66
....................    lcd_send_byte(0,2); 
3FE2:  CLRF   73
3FE4:  MOVLW  02
3FE6:  MOVWF  74
3FE8:  CALL   0B66
....................  
....................  
....................    while(1){ 
....................       /* 
....................          Esta será la parte del programa que estará ejecutándose permanentemente 
....................       */ 
....................       comprobar_temperatura();   // Comprueba si debe o no encender el calentador del agua 
3FEC:  CALL   18BA
....................  
....................       if (flag!=1 && flagDepuradora!=1){                 // Si no están activos los flags del menú 
3FF0:  DECFSZ 31,W
3FF2:  BRA    3FF6
3FF4:  BRA    4004
3FF6:  DECFSZ 32,W
3FF8:  BRA    3FFC
3FFA:  BRA    4004
....................          mostrar_lcd();             // Muestra datos del estado actual de la piscina por el LCD 
3FFC:  CALL   1F04
....................          mostrar_rs232();           // Muestra los valores guardados en Eeprom, por la interfaz RS232 
4000:  CALL   23B2
....................       } 
....................       if (flag==1) 
4004:  DECFSZ 31,W
4006:  BRA    400A
....................          menu();                    // Si el flag está activo, muestra el menú de usuario 
4008:  BRA    3C78
....................  
....................       if (flagDepuradora==1){ 
400A:  DECFSZ 32,W
400C:  BRA    4012
....................          funcionaDepuradora(); 
400E:  CALL   27A0
4012:  CLRF   18
4014:  BTFSC  FF2.7
4016:  BSF    18.7
4018:  BCF    FF2.7
....................       } 
....................       if (difCloro<=0.0 && difTurbidez<=0.0) 
401A:  MOVFF  28,7E
401E:  MOVFF  27,7D
4022:  MOVFF  26,7C
4026:  MOVFF  25,7B
402A:  CLRF   x82
402C:  CLRF   x81
402E:  CLRF   x80
4030:  CLRF   7F
4032:  CALL   0742
4036:  BTFSC  18.7
4038:  BSF    FF2.7
403A:  BC    403E
403C:  BNZ   406C
403E:  CLRF   18
4040:  BTFSC  FF2.7
4042:  BSF    18.7
4044:  BCF    FF2.7
4046:  MOVFF  2C,7E
404A:  MOVFF  2B,7D
404E:  MOVFF  2A,7C
4052:  MOVFF  29,7B
4056:  CLRF   x82
4058:  CLRF   x81
405A:  CLRF   x80
405C:  CLRF   7F
405E:  CALL   0742
4062:  BTFSC  18.7
4064:  BSF    FF2.7
4066:  BC    406A
4068:  BNZ   406C
....................          sleep();                   // Si no está dosificando cloro o floculante, el PIC duerme, hasta que le 
406A:  SLEEP 
....................                                     // despierte el perro guardián o alguna interrupción externa 
....................  
....................    } 
406C:  BRA    3FEC
....................  
....................  
.................... } 
406E:  SLEEP 

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 1F1E   BROWNOUT WDT BORV25 PUT WDT32768
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
